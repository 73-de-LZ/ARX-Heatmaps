<!DOCTYPE html>
<!-- version 5.10 -->
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>RadiosondeAutoRx Real Heat</title>
	<style>
		:root {
			--bg-color: #121212;
			--text-color: #e0e0e0;
			--primary-color: #178c99;
			--secondary-color: #03dac6;
			--error-color: #cf6679;
			--surface-color: #1e1e1e;
			--border-color: #333;
		}

		body {
			font-family: Arial, sans-serif;
			max-width: 1200px;
			margin: 0 auto;
			padding: 20px;
			line-height: 1.6;
			background-color: var(--bg-color);
			color: var(--text-color);
		}

		#status {
			margin: 20px 0;
			padding: 10px;
			border-radius: 4px;
		}

		.info {
			background-color: #1a237e;
			border-left: 6px solid var(--primary-color);
		}

		.success {
			background-color: #1b5e20;
			border-left: 6px solid var(--secondary-color);
		}

		.error {
			background-color: #b71c1c;
			border-left: 6px solid var(--error-color);
		}

		table {
			width: 100%;
			border-collapse: collapse;
			margin-top: 20px;
			background-color: var(--surface-color);
		}

		th,
		td {
			border: 1px solid var(--border-color);
			padding: 4px 8px; /* Reduced from 8px (now 4px top/bottom, 8px left/right) */
			text-align: left;
			line-height: 1; /* Added for tighter text spacing */
		}

		th {
			background-color: #333;
			position: sticky;
			top: 0;
			padding: 3px 8px; /* Slightly less padding for headers */
		}

		tr:nth-child(even) {
			background-color: #252525;
		}

		#controls {
			margin: 20px 0;
			display: flex;
			gap: 10px;
			flex-wrap: wrap;
		}

		button {
			padding: 8px 16px;
			color: white;
			border: none;
			border-radius: 4px;
			cursor: pointer;
			transition: background-color 0.3s;
		}

		button:hover {
			opacity: 0.9;
		}

		button:disabled {
			background-color: #555 !important;
			cursor: not-allowed;
		}

		#updateDbBtn {
			background-color: #3700b3;
		}

		#clearDbBtn {
			background-color: #b00020;
		}

		#queryBtn {
			background-color: var(--secondary-color);
			color: #000;
		}

		#configBtn {
			background-color: #018786;
		}
		
		#searchSerialBtn {
			background-color: var(--primary-color);
			margin-right: 10px;
		}

		#DistAltBtn {
			background-color: #6da6e8;
			color: black;
		}
		#AzAltBtn {
			background-color: #6da6e8;
			color: black;
		}
		#AzElBtn {
			background-color: #6da6e8;
			color: black;
		}

		input,
		select {
			padding: 8px;
			border-radius: 4px;
			border: 1px solid var(--border-color);
			background-color: var(--surface-color);
			color: var(--text-color);
		}

		#fileList {
			margin: 10px 0;
			max-height: 150px;
			overflow-y: auto;
			border: 1px solid var(--border-color);
			padding: 10px;
			border-radius: 4px;
			background-color: var(--surface-color);
		}

		.progress-container {
			width: 100%;
			background-color: #333;
			border-radius: 4px;
			margin: 10px 0;
		}

		.progress-bar {
			height: 20px;
			background-color: var(--secondary-color);
			border-radius: 4px;
			width: 0%;
			transition: width 0.3s;
		}

		#stationInfo {
			margin: 10px 0;
			padding: 10px;
			background-color: var(--surface-color);
			border-radius: 4px;
			border-left: 4px solid var(--primary-color);
		}

		#configDialog {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background: var(--surface-color);
			padding: 20px;
			border-radius: 5px;
			box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
			z-index: 1000;
			width: 300px;
			border: 1px solid var(--primary-color);
		}

		#configDialog h3 {
			margin-top: 0;
			color: var(--primary-color);
		}

		#configDialog label {
			display: block;
			margin: 10px 0 5px;
		}

		#configDialog input {
			width: 100%;
			box-sizing: border-box;
		}

		#configDialog .buttons {
			margin-top: 15px;
			display: flex;
			justify-content: flex-end;
			gap: 10px;
		}

		.overlay {
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: rgba(0, 0, 0, 0.7);
			z-index: 999;
		}
	</style>
</head>
<body>
	<h3>ARX Heatmaps &nbsp - &nbsp Radiosonde_Auto_RX Log Visualizer &nbsp - &nbsp Seek deep with DeepSeek</h3>
	<div id="heatmapplots">	
		<button id="DistAltBtn" disabled>SNR vs DIST-ALT</button>
		<button id="AzAltBtn" disabled>SNR vs AZ-ALT</button>
		<button id="AzElBtn" disabled>SNR vs AZ-EL</button>
	</div>
	<div id="stationInfo">Station: Not configured</div>

	<div id="controls">
		<button id="updateDbBtn">Update Database</button>
		<button id="clearDbBtn" disabled>Clear Database</button>
		<button id="queryBtn" disabled>Query Data</button>
		<select id="serialSelect" disabled>
		<option value="">All Serials</option>
		</select>
		<input type="text" id="manualSerialInput" placeholder="Enter Serial" disabled>
		<button id="searchSerialBtn" disabled>Search</button>
		<input type="number" id="limitInput" placeholder="Limit results" value="10000" min="100" max="20000" step="100">
	</div>	


	<div class="progress-container" id="progressContainer" style="display: none;">
		<div class="progress-bar" id="progressBar"></div>
	</div>

	<div id="fileList"></div>

	<div id="status" class="info">Update DB first by selecting the folder containing AutoRX .log files and station.cfg</div>

	<div id="results">
		<table id="dataTable">
			<thead>
				<tr>
					<th>Timestamp</th>
					<th>Serial</th>
					<th>Frame</th>
					<th>Az</th>
					<th>El</th>
					<th>Dist.(km)</th>
					<th>SNR</th>
					<th>Alt</th>
					<th>Lat</th>
					<th>Lon</th>
					<!-- <th>Vel V</th> -->
					<!-- <th>Vel H</th> -->
				</tr>
			</thead>
			<tbody id="tableBody"></tbody>
		</table>
	</div>

	<script>
		// Database setup
		
		const DB_NAME = "RadiosondeDB";
		const DB_VERSION = 3; // Incremented version
		const STORE_NAME = "logEntries";
		const FILE_TRACKER_STORE = "importedFiles";
		const STATION_INFO_STORE = "stationInfo";


		let db;
		let dbInitialized = false;
		const serialFirstRX = new Set();

		// Station configuration
		let stationConfig = {
			lat: null,
			lon: null,
			alt: 0,
			callsign: null,
		};

		// DOM elements
		const updateDbBtn = document.getElementById("updateDbBtn");
		const clearDbBtn = document.getElementById("clearDbBtn");
		const queryBtn = document.getElementById("queryBtn");
		const serialSelect = document.getElementById("serialSelect");
		const limitInput = document.getElementById("limitInput");
		const fileListDiv = document.getElementById("fileList");
		const statusDiv = document.getElementById("status");
		const tableBody = document.getElementById("tableBody");
		const progressContainer = document.getElementById("progressContainer");
		const progressBar = document.getElementById("progressBar");
		const stationInfo = document.getElementById("stationInfo");
		
		const QUERY_LIMIT = 20000;  // Maximum allowed records to query
		const SERIAL_LIMIT = 1000; // Maximum serial numbers to load
		let serialCache = new Set();
		let serialCacheComplete = false;

		// Configure limit input
		limitInput.value = "10000";  // Default value
		limitInput.max = QUERY_LIMIT;
		limitInput.title = `Max ${QUERY_LIMIT} records`; // Tooltip

		// Initialize the database
		function initDB() {
			return new Promise((resolve, reject) => {
				const request = indexedDB.open(DB_NAME, DB_VERSION);

				request.onerror = (event) => {
					reject(new Error("DB open failed: " + event.target.error));
				};

				request.onupgradeneeded = (event) => {
					const db = event.target.result;
					try {
						if (!db.objectStoreNames.contains(STORE_NAME)) {
							const store = db.createObjectStore(STORE_NAME, { 
								keyPath: "id", 
								autoIncrement: true 
							});
							store.createIndex("timestamp", "timestamp", { unique: false });
							store.createIndex("serial", "serial", { unique: false });
							store.createIndex("rxType", "rxType", { unique: false });
						}
						if (!db.objectStoreNames.contains(FILE_TRACKER_STORE)) {
							db.createObjectStore(FILE_TRACKER_STORE, { keyPath: "filename" });
						}
						if (!db.objectStoreNames.contains(STATION_INFO_STORE)) {
							db.createObjectStore(STATION_INFO_STORE, { keyPath: "id" });
						}
					} catch (e) {
						reject(new Error("DB upgrade failed: " + e.message));
					}
				};

				request.onsuccess = (event) => {
					resolve(event.target.result);
				};

				request.onblocked = () => {
					reject(new Error("DB blocked - close other tabs using this DB"));
				};
			});
		}
		
		async function isFileProcessed(filename) {
			return new Promise((resolve) => {
				const tx = db.transaction(FILE_TRACKER_STORE, "readonly");
				const store = tx.objectStore(FILE_TRACKER_STORE);
				const request = store.get(filename);

				request.onsuccess = () => resolve(!!request.result);
				request.onerror = () => resolve(false);
			});
		}

		async function markFileProcessed(filename) {
			return new Promise((resolve, reject) => {
				const tx = db.transaction(FILE_TRACKER_STORE, "readwrite");
				const store = tx.objectStore(FILE_TRACKER_STORE);
				const request = store.put({ filename });

				request.onsuccess = resolve;
				request.onerror = reject;
			});
		}

		// Load station configuration from station.cfg
		async function loadStationConfig(directoryHandle) {
			try {
				const fileHandle = await directoryHandle.getFileHandle("station.cfg");
				const file = await fileHandle.getFile();
				const text = await file.text();

				const latMatch = text.match(/station_lat\s*=\s*(-?[\d.]+)/);
				const lonMatch = text.match(/station_lon\s*=\s*(-?[\d.]+)/);
				const altMatch = text.match(/station_alt\s*=\s*(-?[\d.]+)/);
				const callsignMatch = text.match(/uploader_callsign\s*=\s*([^\s]+)/);
				const aprsUserMatch = text.match(/aprs_user\s*=\s*([^\s]+)/);

				if (latMatch && lonMatch) {
					const newLat = parseFloat(latMatch[1]);
					const newLon = parseFloat(lonMatch[1]);
					const newAlt = altMatch ? parseFloat(altMatch[1]) : 0;
					const newCallsign = callsignMatch ? callsignMatch[1] : aprsUserMatch ? aprsUserMatch[1] : "Unknown";

					// Check if we have existing station info
					try {
						const existingInfo = await getStationInfo();
						if (existingInfo) {
							// Compare locations
							const locationChanged = 
								Math.abs(existingInfo.lat - newLat) > 0.0001 ||
								Math.abs(existingInfo.lon - newLon) > 0.0001 ||
								Math.abs(existingInfo.alt - newAlt) > 1;
							
							if (locationChanged) {
								const confirmUpdate = confirm(
									"MAJOR ERROR: DB contains information for another station (" + 
									existingInfo.callsign + " @ " + existingInfo.lat.toFixed(4) + ", " + 
									existingInfo.lon.toFixed(4) + ").\n\n" +
									"New station: " + newCallsign + " @ " + newLat.toFixed(4) + ", " + 
									newLon.toFixed(4) + "\n\n" +
									"Database will be updated with new data calculated for the new station, " +
									"but visualization will not be correct.\n\n" +
									"Create another DB for the new station or correct location in station.cfg?\n\n" +
									"Click OK to proceed with update (not recommended), " +
									"or Cancel to abort."
								);
								
								if (!confirmUpdate) {
									statusDiv.textContent = "Update aborted - station location changed";
									statusDiv.className = "error";
									return false;
								}
							}
						}
					} catch (e) {
						console.log("No existing station info or error reading it", e);
					}

					// Update station config
					stationConfig.lat = newLat;
					stationConfig.lon = newLon;
					stationConfig.alt = newAlt;
					stationConfig.callsign = newCallsign;

					// Save the new station info
					await saveStationInfo();
					updateStationInfo();
					return true;
				} else {
					statusDiv.textContent = "station.cfg found but missing location data";
					statusDiv.className = "error";
					return false;
				}
			} catch (error) {
				statusDiv.textContent = "No station.cfg found or error reading it. Please ensure station.cfg exists in the log directory.";
				statusDiv.className = "error";
				return false;
			}
		}

		async function saveStationInfo() {
			return new Promise((resolve, reject) => {
				const transaction = db.transaction([STATION_INFO_STORE], "readwrite");
				const store = transaction.objectStore(STATION_INFO_STORE);
				const info = {
					id: 1, // Single record with fixed ID
					callsign: stationConfig.callsign,
					lat: stationConfig.lat,
					lon: stationConfig.lon,
					alt: stationConfig.alt,
					timestamp: new Date().toISOString()
				};
				
				const request = store.put(info);
				
				request.onsuccess = resolve;
				request.onerror = (event) => reject(event.target.error);
			});
		}

		async function getStationInfo() {
			return new Promise((resolve, reject) => {
				const transaction = db.transaction([STATION_INFO_STORE], "readonly");
				const store = transaction.objectStore(STATION_INFO_STORE);
				const request = store.get(1);
				
				request.onsuccess = () => resolve(request.result);
				request.onerror = (event) => reject(event.target.error);
			});
		}


		// Update station info display
		async function updateStationInfo() {
			let infoText = "";

			if (stationConfig.callsign) {
				infoText = `Station: ${stationConfig.callsign} | Location: ${stationConfig.lat.toFixed(4)}, ${stationConfig.lon.toFixed(4)}, ${stationConfig.alt}m`;
			} else {
				infoText = "Station: Not configured";
			}

			// Add counts if database is initialized
			if (dbInitialized) {
				try {
					// Get all counts in parallel
					const [totalRecords, serialsCount, filesCount] = await Promise.all([
						getTotalRecordsCount(),
						getSerialsCount(),
						getFilesCount(),
					]);

					infoText += ` | Records: ${totalRecords} | Serials: ${serialsCount} | Files: ${filesCount}`;
				} catch (e) {
					console.error("Error getting counts:", e);
					infoText += " | Counts: Error";
				}
			}

			stationInfo.textContent = infoText;
		}

		// Helper Get total records count
		async function getTotalRecordsCount() {
			return new Promise((resolve, reject) => {
				const transaction = db.transaction([STORE_NAME], "readonly");
				const store = transaction.objectStore(STORE_NAME);
				const request = store.count();

				request.onsuccess = () => resolve(request.result);
				request.onerror = (event) => reject(event.target.error);
			});
		}

		// Helper Get unique serials count (updated to be more efficient)
		async function getSerialsCount() {
			return new Promise((resolve, reject) => {
				const transaction = db.transaction([STORE_NAME], "readonly");
				const store = transaction.objectStore(STORE_NAME);
				const request = store.openCursor();
				const uniqueSerials = new Set();
				let counter = 0;

				request.onsuccess = function (event) {
					const cursor = event.target.result;
					if (cursor) {
						const serial = cursor.value.serial;
						if (serial !== undefined && serial !== null) {
							uniqueSerials.add(serial);
						}

						counter++;

						// Call cursor.continue() immediately to keep transaction alive
						cursor.continue();

						// Delay after every 5000 rows, but do not block the transaction
						if (counter % 5000 === 0) {
							// Schedule a non-blocking delay (no await!)
							setTimeout(() => {}, 0);
						}
					} else {
						resolve(uniqueSerials.size);
					}
				};

				request.onerror = (event) => {
					reject(event.target.error);
				};
			});
		}

		// Helper Get imported files count (unchanged)
		async function getFilesCount() {
			return new Promise((resolve, reject) => {
				const transaction = db.transaction([FILE_TRACKER_STORE], "readonly");
				const store = transaction.objectStore(FILE_TRACKER_STORE);
				const request = store.count();
				request.onsuccess = () => resolve(request.result);
				request.onerror = (event) => reject(event.target.error);
			});
		}

		function calculatePositionMetrics(stationLat, stationLon, stationAlt, sondeLat, sondeLon, sondeAlt) {
			// Earth's radius in meters
			const R = 6371000;

			// Convert coordinates to radians
			const φ1 = (stationLat * Math.PI) / 180;
			const φ2 = (sondeLat * Math.PI) / 180;
			const Δφ = ((sondeLat - stationLat) * Math.PI) / 180;
			const Δλ = ((sondeLon - stationLon) * Math.PI) / 180;

			// Calculate horizontal distance (Haversine formula)
			const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
			const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
			const horizontalDist = R * c; // in meters

			// Altitude difference
			const verticalDist = sondeAlt - stationAlt; // in meters

			// Calculate 3D distance (Pythagorean theorem)
			const distance3D = Math.sqrt(horizontalDist * horizontalDist + verticalDist * verticalDist);

			// Calculate elevation angle (arctangent of vertical/horizontal)
			const elevationRad = Math.atan2(verticalDist, horizontalDist);
			const elevationDeg = (elevationRad * 180) / Math.PI;

			// Calculate azimuth (compass direction)
			const y = Math.sin(Δλ) * Math.cos(φ2);
			const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
			let azimuthRad = Math.atan2(y, x);
			let azimuthDeg = (azimuthRad * 180) / Math.PI;

			// Normalize to 0-360 degrees
			azimuthDeg = (azimuthDeg + 360) % 360;

			return {
				distance: distance3D / 1000, // Convert to km
				elevation: elevationDeg,
				horizontalDist: horizontalDist / 1000, // Optional, in km
				azimuth: azimuthDeg,
			};
		}

		// Clear the database
		async function clearDB() {
			return new Promise((resolve, reject) => {
				// Create a transaction that includes all object stores
				const transaction = db.transaction(
					[STORE_NAME, FILE_TRACKER_STORE, STATION_INFO_STORE], 
					"readwrite"
				);

				// Clear each object store
				const logStore = transaction.objectStore(STORE_NAME);
				const fileStore = transaction.objectStore(FILE_TRACKER_STORE);
				const stationStore = transaction.objectStore(STATION_INFO_STORE);

				// Track completion of all clear operations
				let operationsCompleted = 0;
				const totalOperations = 3;
				let anyError = null;

				function checkCompletion() {
					operationsCompleted++;
					if (operationsCompleted === totalOperations) {
						if (anyError) {
							reject(anyError);
						} else {
							// All clears completed successfully
							statusDiv.textContent = "Database fully cleared";
							statusDiv.className = "success";
							tableBody.innerHTML = "";
							serialSelect.innerHTML = '<option value="">All Serials</option>';
							// Reset station config
							stationConfig = {
								lat: null,
								lon: null,
								alt: 0,
								callsign: null
							};
							updateStationInfo();
							resolve();
						}
					}
				}

				// Clear log entries store
				const logClearRequest = logStore.clear();
				logClearRequest.onsuccess = checkCompletion;
				logClearRequest.onerror = (event) => {
					anyError = event.target.error;
					checkCompletion();
				};

				// Clear file tracker store
				const fileClearRequest = fileStore.clear();
				fileClearRequest.onsuccess = checkCompletion;
				fileClearRequest.onerror = (event) => {
					anyError = event.target.error;
					checkCompletion();
				};

				// Clear station info store
				const stationClearRequest = stationStore.clear();
				stationClearRequest.onsuccess = checkCompletion;
				stationClearRequest.onerror = (event) => {
					anyError = event.target.error;
					checkCompletion();
				};

				// Transaction error handler
				transaction.onerror = (event) => {
					anyError = event.target.error;
					// Don't call checkCompletion here as individual operations might still complete
				};
			});
		}


		// Query data from the database
		function queryData(serial = "", limit = 100) {
			return new Promise((resolve, reject) => {
				const transaction = db.transaction([STORE_NAME], "readonly");
				const store = transaction.objectStore(STORE_NAME);
				let request;
				const results = [];

				if (serial) {
					const index = store.index("serial");
					const range = IDBKeyRange.only(serial);
					request = index.openCursor(range, "prev");  // reverse chronological
				} else {
					request = store.openCursor(null, "prev");
				}

				request.onsuccess = (event) => {
					const cursor = event.target.result;
					if (cursor && results.length < limit) {
						results.push(cursor.value);
						cursor.continue();
					} else {
						resolve(results);
					}
				};

				request.onerror = (event) => {
					reject(event.target.error);
				};
			});
		}

		// ensure accurate serial numbers:
		async function updateSerialList() {
			try {
				statusDiv.textContent = "Loading recent serial numbers...";
				statusDiv.className = "info";
				serialSelect.disabled = true;

				// Clear dropdown
				serialSelect.innerHTML = '<option value="">All Serials</option>';

				// Get most recent timestamp
				const latestTimestamp = await new Promise((resolve, reject) => {
					const tx = db.transaction(STORE_NAME, "readonly");
					const store = tx.objectStore(STORE_NAME);
					const index = store.index("timestamp");
					const cursorReq = index.openCursor(null, "prev"); // descending

					cursorReq.onsuccess = (e) => {
						const cursor = e.target.result;
						if (cursor && cursor.value.timestamp) {
							resolve(cursor.value.timestamp);
						} else {
							resolve(null);
						}
					};
					cursorReq.onerror = () => reject("Failed to read latest timestamp");
				});

				if (!latestTimestamp) {
					statusDiv.textContent = "No data found in DB";
					statusDiv.className = "error";
					return;
				}

				// Calculate 30-day cutoff
				const latestDate = new Date(latestTimestamp);
				const cutoffDate = new Date(latestDate);
				cutoffDate.setDate(latestDate.getDate() - 30);
				const cutoffISO = cutoffDate.toISOString();

				// Query all records within 30 days
				const serials = new Set();
				const tx = db.transaction(STORE_NAME, "readonly");
				const store = tx.objectStore(STORE_NAME);
				const index = store.index("timestamp");
				const range = IDBKeyRange.lowerBound(cutoffISO);
				const req = index.openCursor(range, "prev");

				req.onsuccess = (e) => {
					const cursor = e.target.result;
					if (cursor) {
						if (cursor.value.serial) {
							serials.add(cursor.value.serial);
						}
						cursor.continue();
					} else {
						// Done
						const sortedSerials = Array.from(serials).sort();
						for (const s of sortedSerials) {
							const opt = document.createElement("option");
							opt.value = s;
							opt.textContent = s;
							serialSelect.appendChild(opt);
						}
						statusDiv.textContent = `Loaded ${serials.size} recent serials`;
						statusDiv.className = "success";
						serialSelect.disabled = false;
					}
				};
				req.onerror = () => {
					statusDiv.textContent = "Error loading serials";
					statusDiv.className = "error";
					serialSelect.disabled = false;
				};
			} catch (e) {
				console.error("updateSerialList error:", e);
				statusDiv.textContent = "Serial loading failed";
				statusDiv.className = "error";
				serialSelect.disabled = false;
			}
		}


		// Add this new function to check if a serial exists
		async function checkSerialExists(serial) {
			if (serialCache.has(serial)) return true;
			
			return new Promise((resolve) => {
				const transaction = db.transaction([STORE_NAME], "readonly");
				const store = transaction.objectStore(STORE_NAME);
				const index = store.index("serial");
				const request = index.getKey(serial);
				
				request.onsuccess = () => resolve(!!request.result);
				request.onerror = () => resolve(false);
			});
		}

		// Parse a single CSV line and calculate distance
		function parseCSVLine(line, headers) {
			const values = line.split(",");
			const entry = {rxType: 0};

			headers.forEach((header, index) => {
				if (index < values.length) {
					let value = values[index].trim();

					if (["lat", "lon", "alt", "vel_v", "vel_h", "heading", "temp", "humidity", "pressure", "freq_mhz", "snr", "f_error_hz", "sats", "batt_v", "burst_timer"].includes(header)) {
						value = value === "-1" || value === "" ? null : parseFloat(value);
					}

					if (header === "type" && value.startsWith("0x")) {
						value = parseInt(value.substring(2), 16);
					}

					entry[header] = value;
				}
			});

			// Calculate position metrics if we have valid coordinates
			if (stationConfig.lat !== null && stationConfig.lon !== null && entry.lat !== null && entry.lon !== null && entry.alt !== null) {
				const metrics = calculatePositionMetrics(stationConfig.lat, stationConfig.lon, stationConfig.alt, entry.lat, entry.lon, entry.alt);

				entry.distance = metrics.distance;
				entry.elevation = metrics.elevation;
				entry.azimuth = metrics.azimuth; // Add azimuth to the entry
			} else {
				entry.distance = null;
				entry.elevation = null;
				entry.azimuth = null;
			}

			return entry;
		}

		async function processFile(file) {
			return new Promise((resolve, reject) => {
				const reader = new FileReader();
				reader.onload = async (event) => {
					try {
						const content = event.target.result;
						const lines = content.split('\n');
						
						if (lines.length < 3) { // Need header + min 2 data lines
							return resolve({ file: file.name, count: 0, skipped: 0 });
						}

						const headers = lines[0].split(',').map(h => h.trim());
						let count = 0;
						let skipped = 0;
						const batchSize = 1000;
						let batch = [];
						const totalLines = lines.length;

						for (let i = 1; i < totalLines; i++) {
							const line = lines[i].trim();
							if (!line) continue;

							try {
								const entry = parseCSVLine(line, headers);
								
								// Determine RX type - fixed logic
								if (i === 1) {
									entry.rxType = 1; // firstRX
								} else if (i === totalLines - 2) {
									entry.rxType = 2; // lastRX
								} else {
									entry.rxType = 0; // normal
								}
								
								batch.push(entry);

								if (batch.length >= batchSize) {
									await saveBatch(batch);
									count += batch.length;
									batch = [];
								}
							} catch (e) {
								skipped++;
							}
						}

						if (batch.length > 0) {
							await saveBatch(batch);
							count += batch.length;
						}

						resolve({ file: file.name, count, skipped });
					} catch (e) {
						reject(e);
					}
				};
				reader.onerror = () => reject(new Error(`Error reading file ${file.name}`));
				reader.readAsText(file);
			});
		}

		// Save a batch of entries to IndexedDB
		function saveBatch(batch) {
			return new Promise((resolve, reject) => {
				const transaction = db.transaction([STORE_NAME], "readwrite");
				const store = transaction.objectStore(STORE_NAME);

				batch.forEach((entry) => {
					store.add(entry);
				});

				transaction.oncomplete = () => {
					resolve();
				};

				transaction.onerror = (event) => {
					reject(event.target.error);
				};
			});
		}
		
		async function searchSerial(serial) {
			if (!serial) return false;
			
			return new Promise((resolve) => {
				const transaction = db.transaction([STORE_NAME], "readonly");
				const store = transaction.objectStore(STORE_NAME);
				const index = store.index("serial");
				const request = index.getKey(serial);
				
				request.onsuccess = () => resolve(!!request.result);
				request.onerror = () => resolve(false);
			});
		}
		
		// Display data in the table
		function displayData(data) {
			tableBody.innerHTML = "";

			if (data.length === 0) {
				const row = document.createElement("tr");
				const cell = document.createElement("td");
				cell.colSpan = 11; // Adjusted column span
				cell.textContent = "No data found";
				row.appendChild(cell);
				tableBody.appendChild(row);
				return;
			}

			data.forEach((entry, index) => {
				const row = document.createElement("tr");
				
				// Highlight first and last records
				if (entry.rxType === 1) {
					row.style.backgroundColor = "#074a0d"; // Light green for first record
				} else if (entry.rxType === 2) {
					row.style.backgroundColor = "#5c0808"; // Light red for last record
				}

				const addCell = (value, precision = null) => {
					const cell = document.createElement("td");
					if (value === null || value === undefined) {
						cell.textContent = "N/A";
					} else if (precision !== null && typeof value === "number") {
						cell.textContent = value.toFixed(precision);
					} else {
						cell.textContent = value;
					}
					row.appendChild(cell);
				};

				// Add cells without RXtype
				addCell(entry.timestamp);
				addCell(entry.serial);
				addCell(entry.frame);
				addCell(entry.distance, 3);
				addCell(entry.elevation, 2);
				addCell(entry.azimuth, 1);
				addCell(entry.snr, 1);
				addCell(entry.alt, 1);
				addCell(entry.lat, 6);
				addCell(entry.lon, 6);

				tableBody.appendChild(row);
			});
		}

		// Event listeners
		// Start initialization when DOM is ready
		document.addEventListener('DOMContentLoaded', () => {
			// Add a small delay to ensure all elements are loaded
			setTimeout(init, 100);
		});
		
		
		updateDbBtn.addEventListener("click", async () => {
			try {
				// Use the File System Access API if available
				if ("showDirectoryPicker" in window) {
					try {
						const dirHandle = await window.showDirectoryPicker();

						// Try to load station configuration first
						const configLoaded = await loadStationConfig(dirHandle);
						if (!configLoaded) {
							return;
						}

						await processDirectory(dirHandle, false);
					} catch (e) {
						if (e.name !== "AbortError") {
							throw e;
						}
					}
				} else {
					// Fallback for browsers without File System Access API
					const input = document.createElement("input");
					input.type = "file";
					input.webkitdirectory = true;
					input.multiple = true;

					input.onchange = async (e) => {
						const files = Array.from(e.target.files).filter((file) => file.name.endsWith(".log"));

						if (files.length === 0) {
							statusDiv.textContent = "No .log files found in selected folder";
							statusDiv.className = "error";
							return;
						}

						// Try to find station.cfg in the selected files
						const cfgFile = Array.from(e.target.files).find((file) => file.name === "station.cfg");

						if (cfgFile) {
							const text = await cfgFile.text();
							const latMatch = text.match(/station_lat\s*=\s*(-?[\d.]+)/);
							const lonMatch = text.match(/station_lon\s*=\s*(-?[\d.]+)/);
							const altMatch = text.match(/station_alt\s*=\s*(-?[\d.]+)/);
							const callsignMatch = text.match(/uploader_callsign\s*=\s*([^\s]+)/);
							const aprsUserMatch = text.match(/aprs_user\s*=\s*([^\s]+)/);

							if (latMatch && lonMatch) {
								stationConfig.lat = parseFloat(latMatch[1]);
								stationConfig.lon = parseFloat(lonMatch[1]);
								stationConfig.alt = altMatch ? parseFloat(altMatch[1]) : 0;
								stationConfig.callsign = callsignMatch ? callsignMatch[1] : aprsUserMatch ? aprsUserMatch[1] : "Unknown";
								updateStationInfo();
							} else {
								statusDiv.textContent = "station.cfg found but missing location data";
								statusDiv.className = "error";
								return;
							}
						} else {
							statusDiv.textContent = "No station.cfg found. Please ensure station.cfg exists in the log directory.";
							statusDiv.className = "error";
							return;
						}

						await processFiles(files, false);
					};

					input.click();
				}
			} catch (e) {
				statusDiv.textContent = "Error: " + e.message;
				statusDiv.className = "error";
				console.error(e);
			}
		});

		clearDbBtn.addEventListener("click", async () => {
			try {
				await clearDB();
				clearDbBtn.disabled = true;
				queryBtn.disabled = false;
				serialSelect.disabled = true;
				updateDbBtn.disabled = false;
			} catch (e) {
				console.error(e);
			}
		});

		queryBtn.addEventListener("click", async () => {
			try {
				// Disable during query
				queryBtn.disabled = true;
				statusDiv.textContent = "Querying data...";
				statusDiv.className = "info";
				
				const serial = serialSelect.value;
				const limit = Math.min(parseInt(limitInput.value) || 10000, QUERY_LIMIT);
				
				const data = await queryData(serial, limit);
				displayData(data);
				
				statusDiv.textContent = `Found ${data.length} records` + 
									  (serial ? ` for ${serial}` : "");
				statusDiv.className = data.length ? "success" : "error";
				
			} catch (e) {
				console.error("Query error:", e);
				statusDiv.textContent = "Query failed: " + (e.message || "Unknown error");
				statusDiv.className = "error";
			} finally {
				// Always re-enable controls
				enableQueryControls();
			}
		});
		DistAltBtn.addEventListener("click", () => {
			window.open("SNR-DIST_ALT.html", "_blank");
		});
		AzAltBtn.addEventListener("click", () => {
			window.open("SNR-AZ_ALT.html", "_blank");
		});
		AzElBtn.addEventListener("click", () => {
			window.open("SNR-AZ_EL.html", "_blank");
		});
		
		document.getElementById("searchSerialBtn").addEventListener("click", async () => {
			const searchBtn = document.getElementById("searchSerialBtn");
			const manualInput = document.getElementById("manualSerialInput");
			
			try {
				searchBtn.disabled = true;
				manualInput.disabled = true;
				
				const serial = manualInput.value.trim();
				if (!serial) return;
				
				statusDiv.textContent = `Checking serial ${serial}...`;
				statusDiv.className = "info";
				
				const exists = await checkSerialExists(serial);
				if (exists) {
					if (!serialCache.has(serial)) {
						const option = document.createElement("option");
						option.value = serial;
						option.textContent = serial;
						serialSelect.appendChild(option);
						serialCache.add(serial);
					}
					serialSelect.value = serial;
					statusDiv.textContent = `Found serial ${serial}`;
					statusDiv.className = "success";
				} else {
					statusDiv.textContent = `Serial ${serial} not found`;
					statusDiv.className = "error";
				}
			} catch (e) {
				statusDiv.textContent = "Error checking serial";
				statusDiv.className = "error";
				console.error("Serial check error:", e);
			} finally {
				searchBtn.disabled = false;
				manualInput.disabled = false;
			}
		});

		// Process directory using File System Access API
		async function processDirectory(dirHandle, clearFirst) {
			statusDiv.textContent = clearFirst ? "Processing directory..." : "Updating database...";
			statusDiv.className = "info";
			fileListDiv.innerHTML = "";
			progressContainer.style.display = "block";
			progressBar.style.width = "0%";

			let totalFiles = 0;
			let processedFiles = 0;
			let totalEntries = 0;
			let skippedEntries = 0;
			const logFiles = [];

			// Count all .log files first
			for await (const entry of dirHandle.values()) {
				if (entry.kind === "file" && entry.name.endsWith(".log")) {
					logFiles.push(entry);
				}
			}
			totalFiles = logFiles.length;

			if (totalFiles === 0) {
				statusDiv.textContent = "No .log files found in selected folder";
				statusDiv.className = "error";
				progressContainer.style.display = "none";
				return;
			}

			// Clear database if this is the initial load
			if (clearFirst) {
				try {
					await clearDB();
					// Also clear the file tracker
					const tx = db.transaction(FILE_TRACKER_STORE, "readwrite");
					const store = tx.objectStore(FILE_TRACKER_STORE);
					await store.clear();
				} catch (e) {
					console.error("Error clearing database:", e);
					statusDiv.textContent = "Error clearing database: " + e.message;
					statusDiv.className = "error";
					progressContainer.style.display = "none";
					return;
				}
			}

			// Process each file
			for (const fileHandle of logFiles) {
				try {
					const file = await fileHandle.getFile();

					// Skip already processed files during updates
					if (!clearFirst && (await isFileProcessed(file.name))) {
						processedFiles++;
						progressBar.style.width = `${(processedFiles / totalFiles) * 100}%`;
						continue;
					}

					const result = await processFile(file);

					// Mark file as processed
					await markFileProcessed(file.name);

					processedFiles++;
					totalEntries += result.count;
					skippedEntries += result.skipped;

					// Update progress
					progressBar.style.width = `${(processedFiles / totalFiles) * 100}%`;

					// Update file list
					const fileDiv = document.createElement("div");
					fileDiv.textContent = `${file.name}: ${result.count} entries${result.skipped > 0 ? ` (${result.skipped} skipped)` : ""}`;
					fileListDiv.appendChild(fileDiv);
					// Keep only the last 20 files visible
					while (fileListDiv.children.length > 20) {
						fileListDiv.removeChild(fileListDiv.firstChild);
					}

					// Update status
					statusDiv.textContent = clearFirst ? `Processed ${processedFiles}/${totalFiles} files, ${totalEntries} entries` : `Updated with ${processedFiles}/${totalFiles} files, added ${totalEntries} entries`;
					statusDiv.className = "info";
				} catch (e) {
					console.error(`Error processing file ${fileHandle.name}:`, e);
					const fileDiv = document.createElement("div");
					fileDiv.textContent = `${fileHandle.name}: ERROR - ${e.message}`;
					fileDiv.style.color = "#ff5252";
					fileListDiv.appendChild(fileDiv);
				}
			}

			progressContainer.style.display = "none";
			statusDiv.textContent = clearFirst
				? `Done! Processed ${totalFiles} .log files with ${totalEntries} entries (${skippedEntries} skipped)`
				: `Database updated! Added ${totalEntries} entries from ${totalFiles} .log files (${skippedEntries} skipped)`;
			statusDiv.className = "success";

			// Update UI
			clearDbBtn.disabled = false;
			queryBtn.disabled = false;
			serialSelect.disabled = false;
			updateDbBtn.disabled = false;

			// Update serial list
			await updateStationInfo();
			await updateSerialList();

			// Show some data
			await queryBtn.click();
		}

		// Process files using the fallback method (simplified version)
		async function processFiles(files, clearFirst) {
			statusDiv.textContent = clearFirst ? "Processing files..." : "Updating database...";
			statusDiv.className = "info";
			fileListDiv.innerHTML = "";
			progressContainer.style.display = "block";
			progressBar.style.width = "0%";

			const totalFiles = files.filter((file) => file.name.endsWith(".log")).length;
			let processedFiles = 0;
			let totalEntries = 0;
			let skippedEntries = 0;

			if (totalFiles === 0) {
				statusDiv.textContent = "No .log files found";
				statusDiv.className = "error";
				progressContainer.style.display = "none";
				return;
			}

			// Clear database if needed
			if (clearFirst) {
				try {
					await clearDB();
					const tx = db.transaction(FILE_TRACKER_STORE, "readwrite");
					const store = tx.objectStore(FILE_TRACKER_STORE);
					await store.clear();
				} catch (e) {
					console.error("Error clearing database:", e);
					statusDiv.textContent = "Error clearing database: " + e.message;
					statusDiv.className = "error";
					progressContainer.style.display = "none";
					return;
				}
			}

			for (const file of files) {
				if (file.name.endsWith(".log")) {
					try {
						// Skip already processed files
						if (!clearFirst && (await isFileProcessed(file.name))) {
							processedFiles++;
							progressBar.style.width = `${(processedFiles / totalFiles) * 100}%`;
							continue;
						}

						const result = await processFileSimple(file);
						await markFileProcessed(file.name);

						processedFiles++;
						totalEntries += result.count;
						skippedEntries += result.skipped;

						// Update progress
						progressBar.style.width = `${(processedFiles / totalFiles) * 100}%`;

						// Update file list
						const fileDiv = document.createElement("div");
						fileDiv.textContent = `${file.name}: ${result.count} entries${result.skipped > 0 ? ` (${result.skipped} skipped)` : ""}`;
						fileListDiv.appendChild(fileDiv);

						statusDiv.textContent = clearFirst 
							? `Processed ${processedFiles}/${totalFiles} files, ${totalEntries} entries`
							: `Updated with ${processedFiles}/${totalFiles} files, added ${totalEntries} entries`;
						statusDiv.className = "info";

					} catch (e) {
						console.error(`Error processing file ${file.name}:`, e);
						const fileDiv = document.createElement("div");
						fileDiv.textContent = `${file.name}: ERROR - ${e.message}`;
						fileDiv.style.color = "#ff5252";
						fileListDiv.appendChild(fileDiv);
					}
				}
			}

			progressContainer.style.display = "none";
			statusDiv.textContent = clearFirst
				? `Done! Processed ${totalFiles} .log files with ${totalEntries} entries (${skippedEntries} skipped)`
				: `Database updated! Added ${totalEntries} entries from ${totalFiles} .log files (${skippedEntries} skipped)`;
			statusDiv.className = "success";

			// Update UI
			clearDbBtn.disabled = false;
			queryBtn.disabled = false;
			serialSelect.disabled = false;
			updateDbBtn.disabled = false;

			await updateStationInfo();
			await updateSerialList();
			await queryBtn.click();
		}

		// Simplified file processor
		async function processFileSimple(file) {
			return new Promise((resolve, reject) => {
				const reader = new FileReader();
				reader.onload = async (event) => {
					try {
						const content = event.target.result;
						const lines = content.split('\n');
						
						if (lines.length < 3) { // Need at least header + 2 lines (first and last)
							return resolve({ count: 0, skipped: 0 });
						}

						const headers = lines[0].split(',').map(h => h.trim());
						let count = 0;
						let skipped = 0;
						const batchSize = 1000;
						let batch = [];
						const totalLines = lines.length;

						for (let i = 1; i < totalLines; i++) {
							const line = lines[i].trim();
							if (!line) continue;

							try {
								const entry = parseCSVLine(line, headers);
								
								// Mark RX types based on line position
								if (i === 1) entry.rxType = 1; // firstRX
								else if (i === totalLines - 1) entry.rxType = 2; // lastRX
								
								batch.push(entry);

								if (batch.length >= batchSize) {
									await saveBatch(batch);
									count += batch.length;
									batch = [];
								}
							} catch (e) {
								skipped++;
							}
						}

						if (batch.length > 0) {
							await saveBatch(batch);
							count += batch.length;
						}

						resolve({ count, skipped });
					} catch (e) {
						reject(e);
					}
				};
				reader.onerror = () => reject(new Error(`Error reading file ${file.name}`));
				reader.readAsText(file);
			});
		}
		
		function enableQueryControls() {
			queryBtn.disabled = false;
			document.getElementById("manualSerialInput").disabled = false;
			document.getElementById("searchSerialBtn").disabled = false;
			serialSelect.disabled = false;
		}

		function disableQueryControls() {
			queryBtn.disabled = true;
			document.getElementById("manualSerialInput").disabled = true;
			document.getElementById("searchSerialBtn").disabled = true;
			serialSelect.disabled = true;
		}

		// Initialize the application
		async function init() {
			try {
				disableQueryControls(); // Start with controls disabled
				
				statusDiv.textContent = "Initializing database...";
				statusDiv.className = "info";
				
				// Initialize the database
				db = await initDB();
				dbInitialized = true;
				
				// Try to load station info
				try {
					const existingInfo = await getStationInfo();
					if (existingInfo) {
						stationConfig.lat = existingInfo.lat;
						stationConfig.lon = existingInfo.lon;
						stationConfig.alt = existingInfo.alt;
						stationConfig.callsign = existingInfo.callsign;
						updateStationInfo();
					}
				} catch (e) {
					console.log("No existing station info or error reading it", e);
				}
				
				// Set up limit input
				limitInput.value = "10000";
				limitInput.max = QUERY_LIMIT;
				
				// Enable basic controls
				clearDbBtn.disabled = false;
				updateDbBtn.disabled = false;
				DistAltBtn.disabled = false;
				AzAltBtn.disabled = false;
				AzElBtn.disabled = false;
				
				// Check if we have any data
				try {
					const count = await getTotalRecordsCount();
					if (count > 0) {
						enableQueryControls();
						statusDiv.textContent = "Ready to query";
						statusDiv.className = "success";
						setTimeout(updateSerialList, 100); // Load serials in background
					} else {
						// Database exists but is empty - this is normal first-run state
						enableQueryControls(); // Enable controls even with empty DB
						statusDiv.textContent = "Database ready - add log files to begin";
						statusDiv.className = "info";
					}
				} catch (e) {
					console.error("Error checking record count:", e);
					// If count check fails, still allow operations
					enableQueryControls();
					statusDiv.textContent = "Database ready - try updating";
					statusDiv.className = "info";
				}
				
			} catch (e) {
				console.error("Init failed:", e);
				statusDiv.textContent = "Initialization failed - try updating database";
				statusDiv.className = "error";
				disableQueryControls();
				
				// Special case: If DB creation failed, show more specific error
				if (e.message.includes("DB open failed")) {
					statusDiv.textContent = "Failed to access database - check browser permissions";
				}
			}
		}

		init();
	</script>
</body>
</html>
