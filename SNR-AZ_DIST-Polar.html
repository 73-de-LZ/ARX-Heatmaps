<!DOCTYPE html>
<!-- Ver.3.20 - With Aggregation/Rendering Separation -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SNR vs Azimuth and Distance</title>
<style>
    /* ===== BASE STYLES ===== */
    body {
        margin: 0;
        padding: 10px;
        background-color: #121212;
        color: #e0e0e0;
        font-family: Arial, sans-serif;
        text-align: center;
    }

    /* ===== MAIN CONTROLS CONTAINER ===== */
    #controls-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
        margin: 20px auto;
        align-items: flex-start;
    }

    /* ===== CONTROL ROWS ===== */
    .controls-row {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        width: 100%;
        justify-content: center;
		margin-bottom: 10px;
    }

    /* ===== CONTROL GROUPS ===== */
    .control-group {
        background-color: #1e1e1e;
        border-radius: 6px;
        padding: 5px;
		justify-content: center;
    }

    .control-group-flex {
        display: flex;
        align-items: center;
    }

    .control-label {
        margin-right: 10px;
    }

    .input-hint {
        margin-left: 6px;
    }

    /* ===== RANGE CONTROLS ===== */
    .range-control {
        background-color: #1e1e1e;
        border-radius: 6px;
        padding: 4px;
    }

    .range-inputs {
        display: flex;
        align-items: center;
        gap: 4px;
    }

    .range-label {
        margin-right: 10px;
        text-align: right;
    }

    /* ===== LOS controls LAYOUT ===== */
	#los-controls-container {
		margin-bottom: 10px;
	}
	.los-controls-grid {
		display: grid;
		grid-template-columns: auto auto auto;
		justify-content: start; /* Changed from center to start */
		gap: 5px;
	}

	.los-controls-group {
		font-size: 0.85em;
		border: 1px solid #444;
		border-radius: 8px;
		padding: 0px;
		margin: auto; /*  centering: auto , left align: 1px 0 1px 0 */
		width: fit-content;
		background-color: #1a1a1a;
		margin-right: auto; /* This forces left alignment */
	}

    /* ===== FORM ROWS ===== */
    .form-row {
        display: flex;
        align-items: center;
        margin-bottom: 0px;
        height: 20px;
        justify-content: space-between;
    }

    /* ===== INPUT ELEMENTS ===== */
    input, select {
        padding: 2px 2px;
        background-color: #1e1e1e;
        color: #e0e0e0;
        border: 1px solid #333;
        border-radius: 4px;
    }

    input[type="number"] {
        width: 50px;
    }

    input[type="color"] {
        width: 40px;
        height: 20px;
        padding: 1px;
    }

	/* ===== BUTTONS ===== */
	.action-buttons {
		display: flex;
		gap: 10px;
		width: 100%;
		margin-top: 10px;
		justify-content: center;
	}
	
	button {
		padding: 5px 10px;
		background-color: #6da6e8;
		color: #000;
		border: none;
		border-radius: 4px;
		font-size: 16px;
	}
	button:hover {
		background-color: #89befa;
	}
	button:disabled {
		opacity: 0.2;
		cursor: not-allowed;
	}
	input:disabled {
    opacity: 0.8;
    cursor: not-allowed;
	}

    #progress-container {
        width: 100%;
        background-color: #333;
        border-radius: 4px;
        margin: 20px 0;
        display: none;
    }
    #progress-bar {
        height: 20px;
        background-color: #6da6e8;
        border-radius: 4px;
        width: 0%;
        transition: width 0.3s;
    }

    #status-message {
        margin: 20px 0;
        padding: 10px;
        border-radius: 4px;
        background-color: #1e1e1e;
    }
	
	/* ===== DENSITY CONTROLS ===== */
	#density-controls-container {
		transition: opacity 0.2s ease;
	}

	#density-controls-container input:disabled {
		background-color: #1a1a1a;
		color: #666;
		border-color: #333;
	}

	#density-controls-container:has(input:disabled) .range-label {
		color: #666;
	}
	
    .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0,0,0,0.9);
        touch-action: manipulation;
    }

    .modal-content {
        display: block;
        max-width: 95vw;
        max-height: 95vh;
        margin: auto;
        position: relative;
        top: 50%;
        transform: translateY(-50%);
        object-fit: contain;
    }

    .modal-close {
        position: fixed;
        top: 20px;
        right: 30px;
        color: #f1f1f1;
        font-size: 40px;
        font-weight: bold;
        cursor: pointer;
        z-index: 1001;
    }
    
    /* Preview container styles */
    #preview-container {
        margin: 20px auto;
        max-width: 800px;
        background-color: #1e1e1e;
        padding: 10px;
        border-radius: 8px;
        display: none; /* Initially hidden */
    }
    
    #preview-canvas {
        width: 800px;
        height: 450px;
        background-color: #121212;
    }
    
    /* ===== RESPONSIVE ADJUSTMENTS ===== */
    @media (max-width: 550px) {
        .los-controls-grid {
            grid-template-columns: 1fr;
        }
        
        .range-label, .control-label {
            min-width: 120px;
        }
        
        .controls-row {
            flex-direction: column;
        }
        
        #preview-container {
            width: 100%;
            padding: 5px;
        }
        
        #preview-canvas {
            width: 100%;
            height: auto;
            aspect-ratio: 16/9;
        }
    }
</style>
</head>
<body>
    <h3>Receiver SNR vs Radiosonde Azimuth and Distance</h3>
<!-- SAMPLING CONTROLS -->	
<div id="sampling-controls-container">
    <!-- First Row AGGREGATE CONTROLS -->
    <div class="controls-row">
        <!-- Sampling Resolution -->
        <div class="control-group control-group-flex">
            <label for="Sresolution" class="control-label">Sampling for:</label>
            <select id="Sresolution">
                <option value="1280x720">HD (1280×720)</option>
                <option value="1366x768">WXGA (1366×768)</option>
                <option value="1920x1080" selected>Full HD (1920×1080)</option>
                <option value="2560x1440">QHD (2560×1440)</option>
                <option value="3840x2160">4K (3840×2160)</option>
            </select>
        </div>

        <!-- Azimuth -->
        <div class="control-group control-group-flex">
            <label class="range-label">Azimuth:</label>
            <div class="range-inputs">
                <input type="number" id="xMin" placeholder="Min" value="0" step="10">
                <span>to</span>
                <input type="number" id="xMax" placeholder="Max" value="360" step="10">
                <span>&#176;</span>
            </div>
        </div>

        <!-- Distance -->
        <div class="control-group control-group-flex">
            <label class="range-label">Distance:</label>
            <div class="range-inputs">
                <input type="number" id="yMin" placeholder="Min" value="0" step="10">
                <span>to</span>
                <input type="number" id="yMax" placeholder="Max" value="900" step="10">
                <span>km</span>
            </div>
        </div>
		<!-- FILTER -->
        <div class="control-group control-group-flex">
            <label class="range-label">Altitude Filter:</label>
            <div class="range-inputs">
                <input type="number" id="zMin" placeholder="Min" value="0" step="0.5">
                <span>to</span>
                <input type="number" id="zMax" placeholder="Max" value="40" step="1">
                <span>km</span>
            </div>
        </div>

        <!-- Button goes here inline -->
        <div class="control-group control-group-flex">
            <button id="aggregateBtn">Aggregate Data</button>
        </div>
    </div>
</div>

<!-- Status and progressbar lines -->
<div id="status-message">Ready to aggregate data...</div>
<canvas id="plotCanvas" style="display: none;"></canvas>
<div id="progress-container">
	<div id="progress-bar"></div>
</div>

<!-- LOS CONTROLS -->
<div id="los-controls-container">
    <!-- LOS Controls -->
    <div class="los-controls-group">
        <div id="losControls" class="los-controls-grid">
            <!-- Column 1 - Observer Settings -->
            <div class="range-control">
                <div class="form-row">
                    <label for="observerHeight" class="range-label">RX Antenna ASL (m):</label>
                    <input type="number" id="observerHeight" value="100" min="0" step="10">
                </div>
                <div class="form-row">
                    <label for="refractionFactor" class="range-label">Refraction Factor:</label>
                    <input type="number" id="refractionFactor" value="1.33" min="1" max="2" step="0.01">
                </div>
            </div>

            <!-- Column 2 - Toggles -->
            <div class="range-control">
                <div class="form-row">
                    <label for="losEnabled" class="range-label">Show Line of Sight:</label>
                    <input type="checkbox" id="losEnabled">
                </div>
                <div class="form-row">
                    <label for="radioHorizonEnabled" class="range-label">Show Radio Horizon:</label>
                    <input type="checkbox" id="radioHorizonEnabled">
                </div>
            </div>

            <!-- Column 3 - Colors -->
            <div class="range-control">
                <div class="form-row">
                    <label for="losColor" class="range-label">LOS Color:</label>
                    <input type="color" id="losColor" value="#44FF00">
                </div>
                <div class="form-row">
                    <label for="radioHorizonColor" class="range-label">Radio Horizon:</label>
                    <input type="color" id="radioHorizonColor" value="#FBFF22">
                </div>
            </div>
        </div>
    </div>
</div>

<!-- RENDER CONTROLS -->
<div id="render-controls-container">
    <!-- RENDER CONTROLS GROUP -->
    <div class="controls-row">
        <div class="control-group control-group-flex " style="display: none;">
                <label for="Presolution" class="control-label">Draw to:</label>
                <select id="Presolution">
                    <option value="1280x720" selected>HD (1280×720)</option>
                    <option value="1366x768">WXGA (1366×768)</option>
                    <option value="1920x1080">Full HD (1920×1080)</option>
                    <option value="2560x1440">QHD (2560×1440)</option>
                    <option value="3840x2160">4K (3840×2160)</option>
                </select>
        </div>
        <!-- Altitude Range -->
        <div class="control-group control-group-flex">
                <select id="snrType">
                    <option value="min">Minimum SNR</option>
                    <option value="avg" selected>Average SNR</option>
                    <option value="max">Maximum SNR</option>
                    <option value="first">First SNR</option>
                    <option value="last">Last SNR</option>
                    <option value="sum">Sum SNR</option>
                    <option value="count">Counts per Point</option>
                </select>
        </div>
		<!-- SNR Range -->
        <div class="control-group control-group-flex">
                <label class="range-label">SNR:</label>
                <div class="range-inputs">
                    <input type="number" id="snrMin" placeholder="Min" value="8" step="1">
                    <span>to</span>
                    <input type="number" id="snrMax" placeholder="Max" value="28" step="1">
                    <span>dB</span>
                </div>
        </div>
        <div class="control-group control-group-flex">
				<!-- &#9728; Brightness by Density (Counts) -->
                <label for="densityEnabled" class="control-label">Highlight Density:</label>
                <input type="checkbox" id="densityEnabled" checked>        
        </div>
        <div class="control-group control-group-flex">
                <!-- Color Scheme -->
                <label for="colorScheme" class="control-label">Color Scheme:</label>
                <select id="colorScheme">
                    <option value="jet">Jet</option>
					<option value="rainbow">Rainbow</option>
                    <option value="viridis">Viridis</option>
                    <option value="plasma" selected>Plasma</option>
                    <option value="magma">Magma</option>
                    <option value="inferno">Inferno</option>
                    <option value="thermal">Thermal</option>
                    <option value="grayscale">Grayscale</option>
                </select>
        </div>
        
        <!-- Button placed here in the same row -->
        <div class="control-group control-group-flex" style="display: none;">
                <button id="renderBtn">Render</button>
        </div>
		<div class="control-group control-group-flex">
                <button id="viewBtn">View</button>
        </div>
        <div class="control-group control-group-flex">
                <button id="downloadBtn">Save PNG</button>
        </div>
    </div>
	<div id="density-controls-container">
		<div class="controls-row">
			<!-- Density Min Brightness -->
			<div class="control-group control-group-flex">
				<label class="range-label">Density Min Brightness:</label>
				<div class="range-inputs">
					<input type="number" id="densityMinBrightness" placeholder="Min" value="0" min="0" max="100" step="10">
					<span>%</span>
				</div>
			</div>
			
			<!-- Density Strength -->
			<div class="control-group control-group-flex">
				<label class="range-label">Density &gamma;-correction:</label>
				<div class="range-inputs">
					<input type="number" id="densityStrength" placeholder="Strength" value="0.7" min="0.1" max="10" step="0.1">
				</div>
			</div>
			
			<!-- Density Max -->
			<div class="control-group control-group-flex">
				<label class="range-label">Density Max Count:</label>
				<div class="range-inputs">
					<input type="number" id="densityMax" placeholder="Max" value="10" min="1" max="99" step="1">
				</div>
			</div>			
		</div>
	</div>
</div> 

<!-- Preview container -->
<div id="preview-container">
    <canvas id="preview-canvas"></canvas>
</div>

<div id="imageModal" class="modal">
    <span class="modal-close">&times;</span>
    <img class="modal-content" id="modalImage">
</div>

<script>
    // =============================================
    // 1. CONFIGURATION AND GLOBALS
    // =============================================
    const METERS_TO_KM = 0.001;
    const MIN_CELL_COUNT = 1; // 2 or more to Filter DP with low density 
	
    const BATCH_SIZE = 20000;
    const MAX_POINTS = 50000000; // limit of DP
    
    // Color schemes
    const COLOR_SCHEMES = {
        jet: [
            [0.0, 0, 0, 128],
            [0.125, 0, 0, 255],
            [0.375, 0, 255, 255],
            [0.625, 255, 255, 0],
            [0.875, 255, 0, 0],
            [1.0, 128, 0, 0]
        ],
        viridis: [
            [0.0, 68, 1, 84],
            [0.25, 59, 82, 139],
            [0.5, 33, 145, 140],
            [0.75, 94, 201, 98],
            [1.0, 253, 231, 37]
        ],
        plasma: [
            [0.0, 13, 8, 135],
            [0.25, 75, 3, 161],
            [0.5, 138, 15, 134],
            [0.75, 191, 57, 85],
            [1.0, 240, 249, 33]
        ],
        magma: [
            [0.0, 0, 0, 4],
            [0.25, 48, 18, 59],
            [0.5, 120, 28, 129],
            [0.75, 189, 55, 84],
            [1.0, 252, 141, 89]
        ],
        inferno: [
            [0.0, 0, 0, 4],
            [0.25, 57, 9, 99],
            [0.5, 134, 21, 102],
            [0.75, 203, 54, 47],
            [1.0, 252, 125, 10]
        ],
        thermal: [
            [0.0, 0, 0, 0],
            [0.5, 255, 0, 0],
            [1.0, 255, 255, 0]
        ],
        rainbow: [
            [0.0, 255, 0, 0],
            [0.2, 255, 255, 0],
            [0.4, 0, 255, 0],
            [0.6, 0, 255, 255],
            [0.8, 0, 0, 255],
            [1.0, 255, 0, 255]
        ],
        grayscale: [
            [0.0, 0, 0, 0],
            [1.0, 255, 255, 255]
        ]
    };

    // Global state (UPDATED)
    let samplingResolution = { width: 1920, height: 1080 };
    let plotArea = null;
    let aggregatedData = null;  // Stores data at sampling resolution
    let maxCount = 1;

    let MIN_SNR = 8;
    let MAX_SNR = 28;
    let lastUpdate = 0;
    let isDataAggregated = false;
	
	// Density vars
	let DENSITY_MIN_BRIGHTNESS = 0;
	let DENSITY_STRENGTH = 0.7; 
	let DENSITY_MAX = 10; 

    // DOM elements
	const SresolutionSelect = document.getElementById('Sresolution'); // sampling Resolution
    const aggregateBtn = document.getElementById('aggregateBtn');
	const xMinInput = document.getElementById('xMin');
    const xMaxInput = document.getElementById('xMax');
    const yMinInput = document.getElementById('yMin');
    const yMaxInput = document.getElementById('yMax');
	const zMinInput = document.getElementById('zMin');
    const zMaxInput = document.getElementById('zMax');
    const statusDiv = document.getElementById('status-message');
    const progressDiv = document.getElementById('progress-container');
    const progressBar = document.getElementById('progress-bar');
	
    const canvas = document.getElementById('plotCanvas');
    const ctx = canvas.getContext('2d');
    const previewCanvas = document.getElementById('preview-canvas');
    const previewCtx = previewCanvas.getContext('2d');
    const previewContainer = document.getElementById('preview-container');

	// LOS DOMs
    const losEnabled = document.getElementById('losEnabled');
    const radioHorizonEnabled = document.getElementById('radioHorizonEnabled');
    const observerHeightInput = document.getElementById('observerHeight');
    const refractionFactorInput = document.getElementById('refractionFactor');
    const losColorInput = document.getElementById('losColor');
    const radioHorizonColorInput = document.getElementById('radioHorizonColor');
	
	// RENDER DOMs
	const renderBtn = document.getElementById('renderBtn'); 
    const viewBtn = document.getElementById('viewBtn');
    const downloadBtn = document.getElementById('downloadBtn');
	
	const snrTypeSelect = document.getElementById('snrType'); // SNR type
    const snrMinInput = document.getElementById('snrMin');
    const snrMaxInput = document.getElementById('snrMax');
	const colorSchemeSelect = document.getElementById('colorScheme');
	// Density
	let densityEnabled = document.getElementById('densityEnabled').checked;
	const densityControlsContainer = document.getElementById('density-controls-container');
	const densityMinBrightnessInput = document.getElementById('densityMinBrightness');
	const densityStrengthInput = document.getElementById('densityStrength');
	const densityMaxInput = document.getElementById('densityMax');

	const modal = document.getElementById('imageModal');
    const modalImg = document.getElementById('modalImage');
    const span = document.querySelector('.modal-close');

    // =============================================
    // 2. AGGREGATION FUNCTIONS
    // =============================================

    function initializeAggregatedData(width, height) {
        const data = new Array(width);
        for (let x = 0; x < width; x++) {
            data[x] = new Array(height);
            for (let y = 0; y < height; y++) {
                data[x][y] = {
                    sumSNR: 0,
                    count: 0,
                    minSNR: Infinity,
                    maxSNR: -Infinity,
                    firstSNR: null,
                    lastSNR: null,
                };
            }
        }
        return data;
    }

    async function aggregateData() {
        try {
            disableControls();
            progressDiv.style.display = 'block';
            statusDiv.textContent = "Aggregating data...";
            
            // Set sampling resolution from UI
            samplingResolution = getSamplingResolution();
            
            // Aggregate data at sampling resolution
            await performAggregation();
            
            statusDiv.textContent = "Data aggregation complete! Ready to render.";
            isDataAggregated = true;
            
        } catch (error) {
            console.error('Data aggregation failed:', error);
            statusDiv.textContent = `Error: ${error.message}`;
        } finally {
            renderBtn.disabled = false;
            viewBtn.disabled = false;
            downloadBtn.disabled = false;
            progressDiv.style.display = 'none';
        }
    }

	function performAggregation() {
		return new Promise(async (resolve, reject) => {
			try {
				// Get bounds and settings
				const xMin = 0; // Azimuth starts at 0
				const xMax = 360; // Azimuth ends at 360
				const yMin = parseFloat(yMinInput.value) || 0;
				const yMax = parseFloat(yMaxInput.value) || 900;
				
				// Calculate plot area using SAMPLING resolution
				plotArea = calculatePolarPlotArea(samplingResolution.width, samplingResolution.height);
				
				// Initialize aggregated data structure at SAMPLING resolution
				aggregatedData = initializeAggregatedData(samplingResolution.width, samplingResolution.height);
				
				// Process data from database
				const db = await openDatabase();
				const totalCount = await getRecordCount(db);
				
				await processDatabaseRecords(db, {
					xMin, xMax, yMin, yMax,
					totalCount, plotArea
				});
				
				resolve();
			} catch (error) {
				reject(error);
			}
		});
	}
	
	    function updateAggregatedData(data, x, y, entry) {
        const cell = data[x][y];
        
        // Update basic statistics
        cell.sumSNR += entry.snr;
        cell.count++;
        
        // Update min/max
        if (entry.snr < cell.minSNR) cell.minSNR = entry.snr;
        if (entry.snr > cell.maxSNR) cell.maxSNR = entry.snr;
        
        // Update first/last
        if (cell.firstSNR === null) {
            cell.firstSNR = entry.snr;
        }
        cell.lastSNR = entry.snr;
    }

    // =============================================
    // 3. RENDERING FUNCTIONS
    // =============================================

	function drawALL() {
		if (!isDataAggregated) {
			statusDiv.textContent = "Please aggregate data first!";
			return;
		}

		try {
			statusDiv.textContent = "Rendering polar plot...";
			
			// Get settings
			MIN_SNR = parseFloat(snrMinInput.value) || 8;
			MAX_SNR = parseFloat(snrMaxInput.value) || 28;
			const yMin = parseFloat(yMinInput.value) || 0;
			const yMax = parseFloat(yMaxInput.value) || 900;
			
			// Set canvas size to sampling resolution
			setCanvasSize(samplingResolution.width, samplingResolution.height);
			
			// Calculate polar plot area
			plotArea = calculatePolarPlotArea(samplingResolution.width, samplingResolution.height);
			
			// Clear canvas
			ctx.fillStyle = '#121212';
			ctx.fillRect(0, 0, canvas.width, canvas.height);
			
			// Draw polar grid first
			drawPolarGrid(ctx, plotArea, yMin, yMax);
			
			// Draw heatmap in polar coordinates
			drawPolarSNRPlot(ctx, aggregatedData, plotArea, yMin, yMax);
			
			// Draw overlays (LOS, etc.)
			drawPolarOverlays(ctx, plotArea, yMin, yMax);
			
		} catch (error) {
			console.error('Polar plot rendering failed:', error);
			statusDiv.textContent = `Error: ${error.message}`;
		}
	}

	function drawPolarSNRPlot(ctx, data, plotArea, yMin, yMax) {
		const { centerX, centerY, radius } = plotArea;
		const width = data.length;
		const height = data[0].length;
		const snrType = snrTypeSelect.value;
		
		// Create image data for better performance
		const imageData = ctx.createImageData(width, height);
		const pixels = imageData.data;
		
		for (let x = 0; x < width; x++) {
			for (let y = 0; y < height; y++) {
				const cell = data[x][y];
				const idx = (y * width + x) * 4;
				
				if (cell.count >= MIN_CELL_COUNT) {
					const value = getCellValue(cell, snrType);
					let [r, g, b] = getColorForSNR(value);
					
					if (densityEnabled) {
						let brightness = 0;
						if (cell.count > DENSITY_MAX) {
							brightness = 1;
						} else {
							const densityFactor = Math.pow(cell.count / DENSITY_MAX, DENSITY_STRENGTH);
							brightness = DENSITY_MIN_BRIGHTNESS + (1 - DENSITY_MIN_BRIGHTNESS) * densityFactor;
						}
						r = Math.min(255, r * brightness);
						g = Math.min(255, g * brightness);
						b = Math.min(255, b * brightness);
					}
					
					pixels[idx] = r;
					pixels[idx + 1] = g;
					pixels[idx + 2] = b;
					pixels[idx + 3] = 255;
				} else {
					pixels[idx] = pixels[idx + 1] = pixels[idx + 2] = pixels[idx + 3] = 0;
				}
			}
		}
		
		// Draw the heatmap in polar coordinates
		ctx.save();
		const clipRadius = radius * 1.02; // Slightly larger to avoid edge clipping
		ctx.beginPath();
		ctx.arc(centerX, centerY, clipRadius, 0, Math.PI * 2);
		ctx.clip();
		
		// Convert Cartesian heatmap to polar
		for (let x = 0; x < width; x++) {
			for (let y = 0; y < height; y++) {
				const idx = (y * width + x) * 4;
				if (pixels[idx + 3] > 0) { // Only draw non-transparent pixels
					// Convert Cartesian to polar
					const azimuth = (x / width) * 360;
					const distance = yMin + (y / height) * (yMax - yMin);
					const angle = (azimuth - 90) * Math.PI / 180; // -90° to put 0° at top
					const r = (distance / yMax) * radius;
					
					const px = centerX + r * Math.cos(angle);
					const py = centerY + r * Math.sin(angle);
					
					// Draw as small rectangle (could optimize with larger sectors)
					ctx.fillStyle = `rgba(${pixels[idx]}, ${pixels[idx + 1]}, ${pixels[idx + 2]}, 255)`;
					ctx.fillRect(px, py, 1, 1);
				}
			}
		}
		ctx.restore();
	}
	// =============================================
    // 3. DATABASE FUNCTIONS
    // =============================================

	function openDatabase() {
		return new Promise((resolve, reject) => {
			const request = indexedDB.open('RadiosondeDB', 2);
			
			request.onupgradeneeded = (event) => {
				const db = event.target.result;
				if (!db.objectStoreNames.contains('logEntries')) {
					const store = db.createObjectStore('logEntries', { keyPath: 'id', autoIncrement: true });
					store.createIndex('azimuth', 'azimuth', { unique: false });
					store.createIndex('alt', 'alt', { unique: false });
					store.createIndex('snr', 'snr', { unique: false });
					store.createIndex('distance', 'distance', { unique: false });
				}
			};
			
			request.onsuccess = () => resolve(request.result);
			request.onerror = (event) => {
				console.error("Database error:", event.target.error);
				reject(new Error("Couldn't open database"));
			};
		});
	}

    function getRecordCount(db) {
        return new Promise((resolve) => {
            const tx = db.transaction(['logEntries'], 'readonly');
            const store = tx.objectStore('logEntries');
            const request = store.count();
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => resolve(0);
        });
    }

    function getRecordsBatch(db, lastKey, batchSize) {
        return new Promise((resolve) => {
            const tx = db.transaction(['logEntries'], 'readonly');
            const store = tx.objectStore('logEntries');
            const request = lastKey 
                ? store.openCursor(IDBKeyRange.lowerBound(lastKey, true))
                : store.openCursor();
            
            const batch = [];
            let counter = 0;
            
            request.onsuccess = (event) => {
                const cursor = event.target.result;
                if (!cursor || counter >= batchSize) {
                    return resolve(batch);
                }
                
                batch.push(cursor.value);
                counter++;
                cursor.continue();
            };
            
            request.onerror = () => resolve(batch);
        });
    }
	
	async function processDatabaseRecords(db, params) {
		const { xMin, xMax, yMin, yMax, totalCount, plotArea } = params;
		const { centerX, centerY, radius } = plotArea;
		
		let lastKey = null;
		let processed = 0;
		let renderedCount = 0;
		lastUpdate = 0;
		
		while (processed < totalCount && renderedCount < MAX_POINTS) {
			const batch = await getRecordsBatch(db, lastKey, BATCH_SIZE);
			if (batch.length === 0) break;
			
			for (let i = 0; i < batch.length; i++) {
				const entry = batch[i];
				if (isValidEntry(entry, xMin, xMax, yMin, yMax)) {
					// Normalize azimuth first
					const normalizedAzimuth = (entry.azimuth + 360) % 360;
					
					// Calculate polar position
					const x = Math.round((normalizedAzimuth / 360) * samplingResolution.width);
					const y = Math.round(((entry.distance - yMin) / (yMax - yMin)) * samplingResolution.height);
					
					if (x >= 0 && x < samplingResolution.width && 
						y >= 0 && y < samplingResolution.height) {
						updateAggregatedData(aggregatedData, x, y, entry);
						renderedCount++;
					}
				}
				lastKey = entry.id;
				processed++;
			}
			
			updateProgress(processed, totalCount);
			await new Promise(resolve => setTimeout(resolve, 0));
		}
		
		maxCount = calculateMaxCount(aggregatedData);
	}
	
	function calculateMaxCount(data) {
        let max = 1;
        for (let x = 0; x < data.length; x++) {
            for (let y = 0; y < data[x].length; y++) {
                if (data[x][y].count > max) {
                    max = data[x][y].count;
                }
            }
        }
        return max;
    }
	
	function isValidEntry(entry, xMin, xMax, yMin, yMax) {
		if (!entry || typeof entry !== 'object') return false;
		
		// Check required fields exist and are valid numbers
		const requiredFields = ['azimuth', 'alt', 'snr', 'distance'];
		for (const field of requiredFields) {
			if (typeof entry[field] !== 'number' || isNaN(entry[field])) {
				return false;
			}
		}
		
		// Get alt filter values
		const zMin = parseFloat((zMinInput.value) || 0) * 1000;
		const zMax = parseFloat((zMaxInput.value) || 40) * 1000;
		
		return entry.azimuth >= xMin && 
			   entry.azimuth <= xMax && 
			   entry.distance >= yMin && 
			   entry.distance <= yMax &&
			   entry.alt >= zMin &&
			   entry.alt <= zMax;
	}
	
    function updateProgress(processed, totalCount) {
        const now = Date.now();
        if (now - lastUpdate > 100) {
            const progress = Math.min(100, (processed / totalCount) * 100);
            progressBar.style.width = `${progress}%`;
            statusDiv.textContent = `Processed ${Math.min(processed, totalCount).toLocaleString()} of ${totalCount.toLocaleString()} records (aggregating data)...`;
            lastUpdate = now;
        }
    }

    // =============================================
    // 4. DRAWING FUNCTIONS
    // =============================================
	function cartesianToPolar(x, y, plotArea, yMin, yMax) {
		const { centerX, centerY, radius } = plotArea;
		const dx = x - centerX;
		const dy = y - centerY;
		const distance = Math.sqrt(dx * dx + dy * dy);
		
		// Calculate azimuth with proper normalization (0° at top, clockwise)
		let azimuth = Math.atan2(dy, dx) * 180 / Math.PI + 90; // +90° to rotate 0° to top
		azimuth = (azimuth + 360) % 360; // Normalize to 0-360
		
		const scaledDistance = (distance / radius) * yMax;
		return { azimuth, distance: scaledDistance };
	}

	function polarToCartesian(azimuth, distance, plotArea, yMin, yMax) {
		const { centerX, centerY, radius } = plotArea;
		// Convert azimuth to radians with 0° at top (-90° offset)
		const angle = (azimuth - 90) * Math.PI / 180;
		const r = (distance / yMax) * radius;
		return {
			x: centerX + r * Math.cos(angle),
			y: centerY + r * Math.sin(angle)
		};
	}
	
	
	function setCanvasSize(width, height) {
        canvas.width = width;
        canvas.height = height;
    }
	
	function drawPolarOverlays(ctxToUse, width, height) {
		const yMin = parseFloat(yMinInput.value) || 0;
		const yMax = parseFloat(yMaxInput.value) || 900;
		
		// Draw polar grid
		drawPolarGrid(ctxToUse, width, height, yMin, yMax);
		
		// Draw color bar, density bar and legend
		drawBarsAndLegend(ctxToUse);
		
		if (losEnabled.checked || radioHorizonEnabled.checked) {
			const observerHeight = parseFloat(observerHeightInput.value) || 0;
			const refractionFactor = parseFloat(refractionFactorInput.value) || 1.33;

			if (radioHorizonEnabled.checked) {
				drawPolarHorizonCurve(ctxToUse, yMin, yMax, plotArea,
					observerHeight, 6371, radioHorizonColorInput.value,
					'Radio Horizon', refractionFactor);
			}

			if (losEnabled.checked) {
				drawPolarHorizonCurve(ctxToUse, yMin, yMax, plotArea,
					observerHeight, 6371, losColorInput.value, 'LOS', 1.0);
			}
		}
	}

	function drawPolarGrid(ctx, plotArea, yMin, yMax) {
		const { centerX, centerY, radius } = plotArea;
		const { width: canvasWidth, height: canvasHeight } = samplingResolution;
		
		const yScaleFactor = canvasHeight / 1080;
		const yLabelXoffset = centerX + 3 * yScaleFactor;
		const yLabelYoffset = centerY - 6 * yScaleFactor;
		
		const titleFontSize = Math.round(18 * yScaleFactor);
		const baseFontSize = Math.round(12 * yScaleFactor);
		
		// Draw concentric circles (distance rings)
		ctx.strokeStyle = '#aaa';
		ctx.setLineDash([1, 1]);
		ctx.lineWidth = 1;
		ctx.textAlign = 'left';
		ctx.textBaseline = 'middle';
		ctx.fillStyle = '#aaa';
		ctx.font = `${baseFontSize}px Arial`;
		
		// Distance rings with normalized angles for labels
		const distanceStep = 100;
		for (let dist = distanceStep; dist <= yMax; dist += distanceStep) {
			const r = (dist / yMax) * radius;
			ctx.beginPath();
			ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
			ctx.stroke();
			
			// Label at normalized 0° position (top)
			ctx.fillText(dist + 'km', yLabelXoffset, yLabelYoffset - r);
		}
		
		// Draw azimuth lines with normalized angles
		ctx.strokeStyle = '#666';
		ctx.setLineDash([1, 3]);
		ctx.textAlign = 'center';
		for (let az = 0; az < 360; az += 30) {
			const normalizedAz = (az + 360) % 360;
			const angle = (normalizedAz - 90) * Math.PI / 180; // -90° for top=0°
			
			ctx.beginPath();
			ctx.moveTo(centerX, centerY);
			ctx.lineTo(
				centerX + radius * Math.cos(angle),
				centerY + radius * Math.sin(angle)
			);
			ctx.stroke();
			
			// Label at edge
			const labelR = radius * 1.03;
			ctx.fillText(
				normalizedAz + '°',	centerX + labelR * Math.cos(angle),	centerY + labelR * Math.sin(angle));
		}
		ctx.setLineDash([]);
	}
	

	function drawPolarHorizonCurve(ctx, yMin, yMax, plotArea, observerHeight, earthRadius, color, label, refractionFactor) {
		const { centerX, centerY, radius } = plotArea;
		
		// Calculate max altitude from zMax input (convert km to meters)
		const maxAltitude = parseFloat(zMaxInput.value || 40) * 1000;
		
		ctx.beginPath();
		ctx.strokeStyle = color;
		ctx.lineWidth = 1;
		
		// Calculate horizon distance for max altitude
		const distanceKm = calculateLineOfSight(maxAltitude, observerHeight, earthRadius, refractionFactor);
		
		// Only draw if within plot bounds
		if (distanceKm >= yMin && distanceKm <= yMax) {
			const plotRadius = (distanceKm - yMin) / (yMax - yMin) * radius;
			
			// Draw the horizon circle
			ctx.arc(centerX, centerY, plotRadius, 0, Math.PI * 2);
			ctx.stroke();			
		}
	}

	function drawBarsAndLegend(ctx) {
		const { width: canvasWidth, height: canvasHeight } = samplingResolution;

		const yScaleFactor = canvasHeight / 1080;
		const xScaleFactor = canvasWidth / 1920;
		const marginTop = 20 * yScaleFactor;
		const barWidth = 360 * xScaleFactor;
		const barHeight = 20 * yScaleFactor;
		const marginRight = 80 * xScaleFactor;
		const barTop = 80 * yScaleFactor;
		const barSpacing = 60 * yScaleFactor;


		const titleFontSize = Math.round(18 * yScaleFactor);
		const barFontSize = Math.round(14 * yScaleFactor);
		const baseFontSize = Math.round(12 * yScaleFactor);
		const tickCount = 7;

		const barX = canvasWidth - marginRight - barWidth;

		const titleYOffset = 8 * yScaleFactor;
		const tickLength = 5 * yScaleFactor;
		const labelYOffset = 20 * yScaleFactor;
		
		// Draw Plot title
		ctx.fillStyle = '#ddd';
        ctx.font = `bold ${titleFontSize}px Arial`;
		ctx.textAlign = 'right';
        ctx.fillText('Radiosonde SNR vs Azimuth and Distance', canvasWidth - marginRight, marginTop);
		

		// ──────────────── SNR BAR ────────────────
		const barY_SNR = barTop;

		// Color gradient
		for (let i = 0; i < barWidth; i++) {
			const normalized = i / barWidth;
			const snr = MIN_SNR + normalized * (MAX_SNR - MIN_SNR);
			const [r, g, b] = getColorForSNR(snr);
			ctx.fillStyle = `rgb(${r},${g},${b})`;
			ctx.fillRect(barX + i, barY_SNR, 1, barHeight);
		}

		ctx.strokeStyle = '#aaa';
		ctx.lineWidth = 1;
		ctx.strokeRect(barX, barY_SNR, barWidth, barHeight);

		ctx.fillStyle = '#aaa';
		ctx.font = `${barFontSize}px Arial`;
		ctx.textAlign = 'center';
		ctx.fillText(snrType === 'count' ? 'Counts per Point' : 'SNR (dB)', barX + barWidth / 2, barY_SNR - titleYOffset);

		ctx.font = `${baseFontSize}px Arial`;
		for (let i = 0; i < tickCount; i++) {
			const snr = MIN_SNR + (i / (tickCount - 1)) * (MAX_SNR - MIN_SNR);
			const x = barX + (i / (tickCount - 1)) * barWidth;

			ctx.beginPath();
			ctx.moveTo(x, barY_SNR + barHeight);
			ctx.lineTo(x, barY_SNR + barHeight + tickLength);
			ctx.stroke();

			ctx.fillText(snr.toFixed(0), x, barY_SNR + barHeight + labelYOffset);
		}

		// ──────────────── DENSITY BAR ────────────────
		if (densityEnabled) {
			const barY_DENSITY = barY_SNR + barHeight + barSpacing;

			const gradient = ctx.createLinearGradient(barX, barY_DENSITY, barX + barWidth, barY_DENSITY);
			gradient.addColorStop(0, `rgba(255,255,255,${DENSITY_MIN_BRIGHTNESS})`);
			gradient.addColorStop(1, 'rgba(255,255,255,1)');

			ctx.fillStyle = gradient;
			ctx.fillRect(barX, barY_DENSITY, barWidth, barHeight);

			ctx.strokeStyle = '#aaa';
			ctx.strokeRect(barX, barY_DENSITY, barWidth, barHeight);

			ctx.fillStyle = '#aaa';
			ctx.font = `${barFontSize}px Arial`;
			ctx.textAlign = 'center';
			ctx.fillText('Density', barX + barWidth / 2, barY_DENSITY - titleYOffset);

			ctx.font = `${baseFontSize}px Arial`;
			for (let i = 0; i < tickCount; i++) {
				const value = (i / (tickCount - 1)) * DENSITY_MAX;
				const x = barX + (i / (tickCount - 1)) * barWidth;

				ctx.beginPath();
				ctx.moveTo(x, barY_DENSITY + barHeight);
				ctx.lineTo(x, barY_DENSITY + barHeight + tickLength);
				ctx.stroke();

				ctx.fillText(value.toFixed(0), x, barY_DENSITY + barHeight + labelYOffset);
			}
		}
		// ──────────────── HORIZON / LOS LABELS UNDER BARS ────────────────
		const horizonTextY = barY_SNR + barHeight * 2 + barSpacing * 2;
		ctx.font = `${titleFontSize}px Arial`;
		ctx.textAlign = 'center';

		const observerHeight = parseFloat(observerHeightInput.value) || 0;
		const refractionFactor = parseFloat(refractionFactorInput.value) || 1.33;
		const maxAltitude = parseFloat(zMaxInput.value || 40) * 1000;

		if (radioHorizonEnabled.checked) {
			const distanceKm = calculateLineOfSight(maxAltitude, observerHeight, 6371, refractionFactor);
			ctx.fillStyle = radioHorizonColorInput.value;
			ctx.fillText(`Radio Horizon: ${distanceKm.toFixed(1)}km @${maxAltitude/1000}km`, canvasWidth - marginRight - barWidth / 2, horizonTextY);
		}

		if (losEnabled.checked) {
			const distanceKm = calculateLineOfSight(maxAltitude, observerHeight, 6371, 1.0);
			ctx.fillStyle = losColorInput.value;
			ctx.fillText(`LOS: ${distanceKm.toFixed(1)}km @${maxAltitude/1000}km`, canvasWidth - marginRight - barWidth / 2, horizonTextY + labelYOffset);
		}
	}
	function calculateLineOfSight(altitude, observerHeight, earthRadius, refractionFactor = 1) {
		const effectiveRadius = earthRadius * 1000 * refractionFactor;
		const d1 = Math.sqrt(2 * effectiveRadius * observerHeight + observerHeight * observerHeight);
		const d2 = Math.sqrt(2 * effectiveRadius * altitude + altitude * altitude);
		return (d1 + d2) / 1000;
	}

    // =============================================
    // 5. HELPER FUNCTIONS
    // =============================================
	// Helper function to get the appropriate value from a cell
	function getCellValue(cell, snrType) {
		switch(snrType) {
			case 'first': return cell.firstSNR;
			case 'last': return cell.lastSNR;
			case 'min': return cell.minSNR;
			case 'max': return cell.maxSNR;
			case 'count': return cell.count;
			case 'sum': return cell.sumSNR;
			case 'avg':
			default: return cell.sumSNR / cell.count;
		}
	}
	
    function getSamplingResolution() {
        const [width, height] = SresolutionSelect.value.split('x').map(Number);
        return { width, height };
    }

    function getColorForSNR(snr) {
        if (isNaN(snr)) return [0, 0, 0, 0];
        
        // Normalize SNR value between MIN_SNR and MAX_SNR to 0-1 range
        const normalized = Math.min(1, Math.max(0, (snr - MIN_SNR) / (MAX_SNR - MIN_SNR)));
        
        // Get selected color scheme
        const scheme = document.getElementById('colorScheme').value;
        const stops = COLOR_SCHEMES[scheme];
        
        // Find the two stops the normalized value falls between
        let lower = stops[0];
        let upper = stops[stops.length - 1];
        
        for (let i = 0; i < stops.length; i++) {
            if (stops[i][0] >= normalized) {
                upper = stops[i];
                lower = i > 0 ? stops[i-1] : upper;
                break;
            }
        }
        
        // If exactly on a stop point, return that color
        if (lower[0] === upper[0]) {
            return [lower[1], lower[2], lower[3]];
        }
        
        // Linearly interpolate between the two colors
        const t = (normalized - lower[0]) / (upper[0] - lower[0]);
        
        return [
            Math.round(lower[1] + t * (upper[1] - lower[1])),  // R
            Math.round(lower[2] + t * (upper[2] - lower[2])),  // G
            Math.round(lower[3] + t * (upper[3] - lower[3]))   // B
        ];
    }

    function calculateTickInterval(range, pixels) {
        const targetTicks = pixels / 100;
        const roughInterval = range / targetTicks;
        
        const magnitude = Math.pow(10, Math.floor(Math.log10(roughInterval)));
        const normalized = roughInterval / magnitude;
        
        let niceInterval;
        if (normalized < 1.5) {
            niceInterval = magnitude;
        } else if (normalized < 3) {
            niceInterval = 2 * magnitude;
        } else if (normalized < 7) {
            niceInterval = 5 * magnitude;
        } else {
            niceInterval = 10 * magnitude;
        }
        
        return niceInterval;
    }
	function disableControls() {
		const controls = [
			SresolutionSelect,
			aggregateBtn,
			xMinInput,
			xMaxInput,
			yMinInput,
			yMaxInput,
			zMinInput,
			zMaxInput,
			viewBtn,
			downloadBtn
		];
		
		controls.forEach(control => {
			control.disabled = true;
		});
	}
	
function renderAndPreview() {
    const renderStart = performance.now();
    if (!isDataAggregated) return;
    drawALL(); // Render the full quality plot at sampling resolution
    
    // Create preview by scaling down the main canvas
    previewCanvas.width = 800;
    previewCanvas.height = Math.round(800 * (canvas.height / canvas.width));

    previewCtx.imageSmoothingEnabled = true;
    previewCtx.drawImage(
        canvas,
        0, 0, canvas.width, canvas.height,
        0, 0, previewCanvas.width, previewCanvas.height
    );
    
    previewContainer.style.display = 'block';
    const renderTime = performance.now() - renderStart;
	statusDiv.textContent = `Render and Draw complete in ${renderTime.toFixed(0)}ms !`;
}
	
	function updateDensityControlsState() {
		const isEnabled = densityEnabled;
		densityMinBrightnessInput.disabled = !isEnabled;
		densityStrengthInput.disabled = !isEnabled;
		densityMaxInput.disabled = !isEnabled;
		densityControlsContainer.style.opacity = isEnabled ? '1' : '0.6';
	}
	
	function calculatePolarPlotArea(width, height) {
		const centerX = width / 2;
		const centerY = height / 2;
		const radius = Math.min(centerX, centerY) * 0.95; // 90% of half size
		
		return {
			centerX,
			centerY,
			radius,
			plotWidth: width,
			plotHeight: height
		};
	}


    // =============================================
    // 6. EVENT HANDLERS
    // =============================================

    aggregateBtn.addEventListener('click', async function() {
        await aggregateData();
		renderAndPreview();
    });
	
	renderBtn.addEventListener('click', function() {
		renderAndPreview();
    });
	
	// SNR type
	snrTypeSelect.addEventListener('change', function() {
		snrType = this.value;
		// Auto-adjust SNR range when switching to sum/count modes
		switch(snrType) {
			case 'count':
					snrMin = 1;    // COLD color for cells with at least 1 count
					snrMax = 50;  // HOT color for 50 or more counts
					snrMinInput.value = snrMin;
					snrMaxInput.value = snrMax;
				break;
				
			case 'sum':
					snrMin = 20;    // COLD color for sum SNR <= 20
					snrMax = 200;  // HOT color at sum SNR >= 200
					snrMinInput.value = snrMin;
					snrMaxInput.value = snrMax;
				break;
		}
		renderAndPreview();
	});
	snrMinInput.addEventListener('change', function() {
		snrMin = this.value;
		renderAndPreview();
	});
	snrMaxInput.addEventListener('change', function() {
		snrMax = this.value;
		renderAndPreview();
	});
	// Add event listeners for the density control inputs
	[densityMinBrightnessInput, densityStrengthInput, densityMaxInput].forEach(input => {
		input.addEventListener('change', function() {
		    DENSITY_MIN_BRIGHTNESS = parseFloat(densityMinBrightnessInput.value) / 100; // Convert % to 0-1.0
			DENSITY_STRENGTH = parseFloat(densityStrengthInput.value);
			DENSITY_MAX = parseInt(densityMaxInput.value);
			renderAndPreview();
		});
    });
	document.getElementById('densityEnabled').addEventListener('change', function() {
		densityEnabled = this.checked;
		updateDensityControlsState();
		renderAndPreview();
	});

	colorSchemeSelect.addEventListener('change', function() {
		renderAndPreview();
	});

	viewBtn.onclick = function() {
		// Create a high-quality version for modal
		const tempCanvas = document.createElement('canvas');
		tempCanvas.width = canvas.width;
		tempCanvas.height = canvas.height;
		const tempCtx = tempCanvas.getContext('2d');
		
		// Fill background
		tempCtx.fillStyle = '#121212';
		tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
		
		// Draw the heatmap with smoothing
		tempCtx.imageSmoothingEnabled = true;
		tempCtx.drawImage(canvas, 0, 0);
		
		// Show modal
		modal.style.display = "block";
		modalImg.src = tempCanvas.toDataURL('image/png', 1.0); // Maximum quality
		document.body.style.overflow = "hidden";
	};

    downloadBtn.addEventListener('click', function() {
        if (!isDataAggregated) {
            statusDiv.textContent = "No data to download - please aggregate and render first!";
            return;
        }
        
        // Create a temporary canvas with background
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        const tempCtx = tempCanvas.getContext('2d');
        
        // Fill with background color
        tempCtx.fillStyle = '#121212';
        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
        
        // Draw the heatmap
        tempCtx.drawImage(canvas, 0, 0);
        
        // Create download link
        const link = document.createElement('a');
        link.download = 'SNR-Az-Dist-plot-' + new Date().toISOString().slice(0, 10) + '.png';
        link.href = tempCanvas.toDataURL('image/png');
        link.click();
    });

    // Close modal when clicking [X]
    span.onclick = function() {
        modal.style.display = "none";
        document.body.style.overflow = "auto";
    };

    // Close modal when clicking outside image
    modal.onclick = function(event) {
        if (event.target === modal) {
            modal.style.display = "none";
            document.body.style.overflow = "auto";
        }
    };

    // Close modal with ESC key
    document.addEventListener('keydown', function(event) {
        if (event.key === "Escape" && modal.style.display === "block") {
            modal.style.display = "none";
            document.body.style.overflow = "auto";
        }
    });

    // Initialize
    function initialize() {
        aggregateBtn.disabled = false; 
        SresolutionSelect.disabled = false; 
        renderBtn.disabled = true;
        viewBtn.disabled = true;
        downloadBtn.disabled = true;
        statusDiv.textContent = "Select settings and click Aggregate Data";
        updateDensityControlsState();
		densityMinBrightnessInput.value = DENSITY_MIN_BRIGHTNESS * 100; // Convert to percentage
		densityStrengthInput.value = DENSITY_STRENGTH;
		densityMaxInput.value = DENSITY_MAX;
        // Set initial resolution
        samplingResolution = getSamplingResolution();
    }

    initialize();
</script>
</body>
</html>