<!DOCTYPE html>
<!-- Ver.3.20 - With Aggregation/Rendering Separation -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SNR vs Azimuth and Altitude</title>
<style>
    /* ===== BASE STYLES ===== */
    body {
        margin: 0;
        padding: 10px;
        background-color: #121212;
        color: #e0e0e0;
        font-family: Arial, sans-serif;
        text-align: center;
    }

    /* ===== MAIN CONTROLS CONTAINER ===== */
    #controls-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
        margin: 20px auto;
        align-items: flex-start;
    }

    /* ===== CONTROL ROWS ===== */
    .controls-row {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        width: 100%;
        justify-content: center;
		margin-bottom: 10px;
    }

    /* ===== CONTROL GROUPS ===== */
    .control-group {
        background-color: #1e1e1e;
        border-radius: 6px;
        padding: 5px;
		justify-content: center;
    }

    .control-group-flex {
        display: flex;
        align-items: center;
    }

    .control-label {
        margin-right: 10px;
    }

    .input-hint {
        margin-left: 6px;
    }

    /* ===== RANGE CONTROLS ===== */
    .range-control {
        background-color: #1e1e1e;
        border-radius: 6px;
        padding: 4px;
    }

    .range-inputs {
        display: flex;
        align-items: center;
        gap: 4px;
    }

    .range-label {
        margin-right: 10px;
        text-align: right;
    }

    /* ===== LOS controls LAYOUT ===== */
	.los-controls-grid {
		display: grid;
		grid-template-columns: auto auto auto;
		justify-content: start; /* Changed from center to start */
		gap: 5px;
	}

	.los-controls-group {
		font-size: 0.85em;
		border: 1px solid #444;
		border-radius: 8px;
		padding: 0px;
		margin: 1px 0 1px 0; /* Removed 'auto' which was centering it */
		width: fit-content;
		background-color: #1a1a1a;
		margin-right: auto; /* This forces left alignment */
	}

    /* ===== FORM ROWS ===== */
    .form-row {
        display: flex;
        align-items: center;
        margin-bottom: 0px;
        height: 20px;
        justify-content: space-between;
    }

    /* ===== INPUT ELEMENTS ===== */
    input, select {
        padding: 2px 2px;
        background-color: #1e1e1e;
        color: #e0e0e0;
        border: 1px solid #333;
        border-radius: 4px;
    }

    input[type="number"] {
        width: 50px;
    }

    input[type="color"] {
        width: 40px;
        height: 20px;
        padding: 1px;
    }

	/* ===== BUTTONS ===== */
	.action-buttons {
		display: flex;
		gap: 10px;
		width: 100%;
		margin-top: 10px;
		justify-content: center;
	}
	
	button {
		padding: 5px 10px;
		background-color: #6da6e8;
		color: #000;
		border: none;
		border-radius: 4px;
		font-size: 16px;
	}
	button:hover {
		background-color: #89befa;
	}
	button:disabled {
		opacity: 0.2;
		cursor: not-allowed;
	}
	input:disabled {
    opacity: 0.8;
    cursor: not-allowed;
	}

    #progress-container {
        width: 100%;
        background-color: #333;
        border-radius: 4px;
        margin: 20px 0;
        display: none;
    }
    #progress-bar {
        height: 20px;
        background-color: #6da6e8;
        border-radius: 4px;
        width: 0%;
        transition: width 0.3s;
    }

    #status-message {
        margin: 20px 0;
        padding: 10px;
        border-radius: 4px;
        background-color: #1e1e1e;
    }
	
	/* ===== DENSITY CONTROLS ===== */
	#density-controls-container {
		transition: opacity 0.2s ease;
	}

	#density-controls-container input:disabled {
		background-color: #1a1a1a;
		color: #666;
		border-color: #333;
	}

	#density-controls-container:has(input:disabled) .range-label {
		color: #666;
	}
	
    .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0,0,0,0.9);
        touch-action: manipulation;
    }

    .modal-content {
        display: block;
        max-width: 95vw;
        max-height: 95vh;
        margin: auto;
        position: relative;
        top: 50%;
        transform: translateY(-50%);
        object-fit: contain;
    }

    .modal-close {
        position: fixed;
        top: 20px;
        right: 30px;
        color: #f1f1f1;
        font-size: 40px;
        font-weight: bold;
        cursor: pointer;
        z-index: 1001;
    }
    
    /* Preview container styles */
    #preview-container {
        margin: 20px auto;
        max-width: 800px;
        background-color: #1e1e1e;
        padding: 10px;
        border-radius: 8px;
        display: none; /* Initially hidden */
    }
    
    #preview-canvas {
        width: 800px;
        height: 450px;
        background-color: #121212;
    }
    
    /* ===== RESPONSIVE ADJUSTMENTS ===== */
    @media (max-width: 550px) {
        .los-controls-grid {
            grid-template-columns: 1fr;
        }
        
        .range-label, .control-label {
            min-width: 120px;
        }
        
        .controls-row {
            flex-direction: column;
        }
        
        #preview-container {
            width: 100%;
            padding: 5px;
        }
        
        #preview-canvas {
            width: 100%;
            height: auto;
            aspect-ratio: 16/9;
        }
    }
</style>
</head>
<body>
    <h3>Receiver SNR vs Radiosonde Azimuth and Altitude</h3>
<!-- SAMPLING CONTROLS -->	
<div id="sampling-controls-container">
    <!-- First Row AGGREGATE CONTROLS -->
    <div class="controls-row">
        <!-- Sampling Resolution -->
        <div class="control-group control-group-flex">
            <label for="Sresolution" class="control-label">Sampling for:</label>
            <select id="Sresolution">
                <option value="1280x720">HD (1280×720)</option>
                <option value="1366x768">WXGA (1366×768)</option>
                <option value="1920x1080">Full HD (1920×1080)</option>
                <option value="2560x1440">QHD (2560×1440)</option>
                <option value="3840x2160" selected>4K (3840×2160)</option>
            </select>
        </div>

        <!-- Azimuth -->
        <div class="control-group control-group-flex">
            <label class="range-label">Azimuth:</label>
            <div class="range-inputs">
                <input type="number" id="xMin" placeholder="Min" value="0" step="10">
                <span>to</span>
                <input type="number" id="xMax" placeholder="Max" value="360" step="10">
                <span>&#176;</span>
            </div>
        </div>

        <!-- Altitude -->
        <div class="control-group control-group-flex">
            <label class="range-label">Altitude:</label>
            <div class="range-inputs">
                <input type="number" id="yMin" placeholder="Min" value="0" step="0.5">
                <span>to</span>
                <input type="number" id="yMax" placeholder="Max" value="40" step="1">
                <span>km</span>
            </div>
        </div>
		<!-- FILTER -->
        <div class="control-group control-group-flex">
                <label class="range-label">Distance Filter:</label>
                <div class="range-inputs">
                    <input type="number" id="zMin" placeholder="Min" value="0" step="10">
                    <span>to</span>
                    <input type="number" id="zMax" placeholder="Max" value="900" step="10">
                    <span>km</span>
                </div>
        </div>

        <!-- Button goes here inline -->
        <div class="control-group control-group-flex">
            <button id="aggregateBtn">Aggregate Data</button>
        </div>
    </div>
</div>

<!-- Status and progressbar lines -->
<div id="status-message">Ready to aggregate data...</div>
<canvas id="plotCanvas" style="display: none;"></canvas>
<div id="progress-container">
	<div id="progress-bar"></div>
</div>

<!-- LOS CONTROLS -->
<div id="los-controls-container" style="display: none;">
    <!-- LOS Controls -->
    <div class="los-controls-group">
        <div id="losControls" class="los-controls-grid">
            <!-- Column 1 - Observer Settings -->
            <div class="range-control">
                <div class="form-row">
                    <label for="observerHeight" class="range-label" style="color: #444;">RX Antenna ASL (m):</label>
                    <input type="number" id="observerHeight" value="100" min="0" step="10" disabled>
                </div>
                <div class="form-row">
                    <label for="refractionFactor" class="range-label" style="color: #444;">Refraction Factor:</label>
                    <input type="number" id="refractionFactor" value="1.33" min="1" max="2" step="0.01" disabled>
                </div>
            </div>

            <!-- Column 2 - Toggles -->
            <div class="range-control">
                <div class="form-row">
                    <label for="losEnabled" class="range-label" style="color: #444;">Show Line of Sight:</label>
                    <input type="checkbox" id="losEnabled" disabled>
                </div>
                <div class="form-row">
                    <label for="radioHorizonEnabled" class="range-label" style="color: #444;">Show Radio Horizon:</label>
                    <input type="checkbox" id="radioHorizonEnabled" disabled>
                </div>
            </div>

            <!-- Column 3 - Colors -->
            <div class="range-control">
                <div class="form-row">
                    <label for="losColor" class="range-label" style="color: #444;">LOS Color:</label>
                    <input type="color" id="losColor" value="#44FF00" disabled>
                </div>
                <div class="form-row">
                    <label for="radioHorizonColor" class="range-label" style="color: #444;">Radio Horizon:</label>
                    <input type="color" id="radioHorizonColor" value="#FBFF22" disabled>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- RENDER CONTROLS -->
<div id="render-controls-container">
    <!-- RENDER CONTROLS GROUP -->
    <div class="controls-row">
        <div class="control-group control-group-flex">
                <label for="Presolution" class="control-label">Draw to:</label>
                <select id="Presolution">
                    <option value="1280x720" selected>HD (1280×720)</option>
                    <option value="1366x768">WXGA (1366×768)</option>
                    <option value="1920x1080">Full HD (1920×1080)</option>
                    <option value="2560x1440">QHD (2560×1440)</option>
                    <option value="3840x2160">4K (3840×2160)</option>
                </select>
        </div>
        <!-- Altitude Range -->
        <div class="control-group control-group-flex">
                <select id="snrType">
                    <option value="min">Minimum SNR</option>
                    <option value="avg" selected>Average SNR</option>
                    <option value="max">Maximum SNR</option>
                    <option value="first">First SNR</option>
                    <option value="last">Last SNR</option>
                    <option value="sum">Sum SNR</option>
                    <option value="count">Counts per Point</option>
                </select>
        </div>
		<!-- SNR Range -->
        <div class="control-group control-group-flex">
                <label class="range-label">SNR:</label>
                <div class="range-inputs">
                    <input type="number" id="snrMin" placeholder="Min" value="8" step="1">
                    <span>to</span>
                    <input type="number" id="snrMax" placeholder="Max" value="28" step="1">
                    <span>dB</span>
                </div>
        </div>
        <div class="control-group control-group-flex">
				<!-- &#9728; Brightness by Density (Counts) -->
                <label for="densityEnabled" class="control-label">Highlight Density:</label>
                <input type="checkbox" id="densityEnabled" checked>        
        </div>
        <div class="control-group control-group-flex">
                <!-- Color Scheme -->
                <label for="colorScheme" class="control-label">Color Scheme:</label>
                <select id="colorScheme">
                    <option value="jet">Jet</option>
					<option value="rainbow" selected>Rainbow</option>
                    <option value="viridis">Viridis</option>
                    <option value="plasma">Plasma</option>
                    <option value="magma">Magma</option>
                    <option value="inferno">Inferno</option>
                    <option value="thermal">Thermal</option>
                    <option value="grayscale">Grayscale</option>
                </select>
        </div>
        
        <!-- Button placed here in the same row -->
        <div class="control-group control-group-flex" style="display: none;">
                <button id="renderBtn">Render</button>
        </div>
		<div class="control-group control-group-flex">
                <button id="viewBtn">View</button>
        </div>
        <div class="control-group control-group-flex">
                <button id="downloadBtn">Save PNG</button>
        </div>
    </div>
	<div id="density-controls-container">
		<div class="controls-row">
			<!-- Density Min Brightness -->
			<div class="control-group control-group-flex">
				<label class="range-label">Density Min Brightness:</label>
				<div class="range-inputs">
					<input type="number" id="densityMinBrightness" placeholder="Min" value="0" min="0" max="100" step="1">
					<span>%</span>
				</div>
			</div>
			
			<!-- Density Strength -->
			<div class="control-group control-group-flex">
				<label class="range-label">Density &gamma;-correction:</label>
				<div class="range-inputs">
					<input type="number" id="densityStrength" placeholder="Strength" value="0.7" min="0.1" max="10" step="0.1">
				</div>
			</div>
			
			<!-- Density Max -->
			<div class="control-group control-group-flex">
				<label class="range-label">Density Max Count:</label>
				<div class="range-inputs">
					<input type="number" id="densityMax" placeholder="Max" value="10" min="1" max="99" step="1">
				</div>
			</div>			
		</div>
	</div>
</div> 

<!-- Preview container -->
<div id="preview-container">
    <canvas id="preview-canvas"></canvas>
</div>

<div id="imageModal" class="modal">
    <span class="modal-close">&times;</span>
    <img class="modal-content" id="modalImage">
</div>

<script>
    // =============================================
    // 1. CONFIGURATION AND GLOBALS
    // =============================================
    const METERS_TO_KM = 0.001;
    const MIN_CELL_COUNT = 2; // minimum count of occurence in that DP to Highlight it by Density (of rxed packets) 
	
    const BATCH_SIZE = 20000;
    const MAX_POINTS = 50000000; // limit of DP
    
    // Color schemes
    const COLOR_SCHEMES = {
        jet: [
            [0.0, 0, 0, 128],
            [0.125, 0, 0, 255],
            [0.375, 0, 255, 255],
            [0.625, 255, 255, 0],
            [0.875, 255, 0, 0],
            [1.0, 128, 0, 0]
        ],
        viridis: [
            [0.0, 68, 1, 84],
            [0.25, 59, 82, 139],
            [0.5, 33, 145, 140],
            [0.75, 94, 201, 98],
            [1.0, 253, 231, 37]
        ],
        plasma: [
            [0.0, 13, 8, 135],
            [0.25, 75, 3, 161],
            [0.5, 138, 15, 134],
            [0.75, 191, 57, 85],
            [1.0, 240, 249, 33]
        ],
        magma: [
            [0.0, 0, 0, 4],
            [0.25, 48, 18, 59],
            [0.5, 120, 28, 129],
            [0.75, 189, 55, 84],
            [1.0, 252, 141, 89]
        ],
        inferno: [
            [0.0, 0, 0, 4],
            [0.25, 57, 9, 99],
            [0.5, 134, 21, 102],
            [0.75, 203, 54, 47],
            [1.0, 252, 125, 10]
        ],
        thermal: [
            [0.0, 0, 0, 0],
            [0.5, 255, 0, 0],
            [1.0, 255, 255, 0]
        ],
        rainbow: [
            [0.0, 255, 0, 0],
            [0.2, 255, 255, 0],
            [0.4, 0, 255, 0],
            [0.6, 0, 255, 255],
            [0.8, 0, 0, 255],
            [1.0, 255, 0, 255]
        ],
        grayscale: [
            [0.0, 0, 0, 0],
            [1.0, 255, 255, 255]
        ]
    };

    // Global state (UPDATED)
    let samplingResolution = { width: 1920, height: 1080 };
    let plotResolution = { width: 1920, height: 1080 };
	const QUALITY_SCALING_THRESHOLD = 0.7; // HQ when scaling below 70%, 0.9 should be more Q, 0.5 turn off two-step scaling for some downscaling
	const INTERMEDIATE_SCALE_FACTOR = 1.5; // 1.5 Slightly less quality but faster, 2.0 even better quality, but slower
    let plotArea = null;
    let aggregatedData = null;  // Stores data at sampling resolution
    let renderedData = null;    // Stores scaled data at plot resolution
    let maxCount = 1;

    let MIN_SNR = 8;
    let MAX_SNR = 28;
    let lastUpdate = 0;
    let isDataAggregated = false;
	
	// Density vars
	let DENSITY_MIN_BRIGHTNESS = 0;
	let DENSITY_STRENGTH = 0.7; 
	let DENSITY_MAX = 10; 

    // DOM elements
	const SresolutionSelect = document.getElementById('Sresolution'); // sampling Resolution
    const aggregateBtn = document.getElementById('aggregateBtn');
	const xMinInput = document.getElementById('xMin');
    const xMaxInput = document.getElementById('xMax');
    const yMinInput = document.getElementById('yMin');
    const yMaxInput = document.getElementById('yMax');
	const zMinInput = document.getElementById('zMin');
    const zMaxInput = document.getElementById('zMax');
    const statusDiv = document.getElementById('status-message');
    const progressDiv = document.getElementById('progress-container');
    const progressBar = document.getElementById('progress-bar');
	
    const canvas = document.getElementById('plotCanvas');
    const ctx = canvas.getContext('2d');
    const previewCanvas = document.getElementById('preview-canvas');
    const previewCtx = previewCanvas.getContext('2d');
    const previewContainer = document.getElementById('preview-container');

	// LOS DOMs
    const losEnabled = document.getElementById('losEnabled');
    const radioHorizonEnabled = document.getElementById('radioHorizonEnabled');
    const observerHeightInput = document.getElementById('observerHeight');
    const refractionFactorInput = document.getElementById('refractionFactor');
    const losColorInput = document.getElementById('losColor');
    const radioHorizonColorInput = document.getElementById('radioHorizonColor');
	
	// RENDER DOMs
	const renderBtn = document.getElementById('renderBtn'); 
    const viewBtn = document.getElementById('viewBtn');
    const downloadBtn = document.getElementById('downloadBtn');
	
	const PresolutionSelect = document.getElementById('Presolution'); // plot Resolution	
	const snrTypeSelect = document.getElementById('snrType'); // SNR type
    const snrMinInput = document.getElementById('snrMin');
    const snrMaxInput = document.getElementById('snrMax');
	const colorSchemeSelect = document.getElementById('colorScheme');
	// Density
	let densityEnabled = document.getElementById('densityEnabled').checked;
	const densityControlsContainer = document.getElementById('density-controls-container');
	const densityMinBrightnessInput = document.getElementById('densityMinBrightness');
	const densityStrengthInput = document.getElementById('densityStrength');
	const densityMaxInput = document.getElementById('densityMax');

	const modal = document.getElementById('imageModal');
    const modalImg = document.getElementById('modalImage');
    const span = document.querySelector('.modal-close');

    // =============================================
    // 2. AGGREGATION FUNCTIONS
    // =============================================

    function initializeAggregatedData(width, height) {
        const data = new Array(width);
        for (let x = 0; x < width; x++) {
            data[x] = new Array(height);
            for (let y = 0; y < height; y++) {
                data[x][y] = {
                    sumSNR: 0,
                    count: 0,
                    minSNR: Infinity,
                    maxSNR: -Infinity,
                    firstSNR: null,
                    lastSNR: null,
                };
            }
        }
        return data;
    }

    async function aggregateData() {
        try {
            disableControls();
            progressDiv.style.display = 'block';
            statusDiv.textContent = "Aggregating data...";
            
            // Set sampling resolution from UI
            samplingResolution = getSamplingResolution();
            
            // Aggregate data at sampling resolution
            await performAggregation();
            
            statusDiv.textContent = "Data aggregation complete! Ready to render at any resolution.";
            isDataAggregated = true;
            
        } catch (error) {
            console.error('Data aggregation failed:', error);
            statusDiv.textContent = `Error: ${error.message}`;
        } finally {
            renderBtn.disabled = false;
            viewBtn.disabled = false;
            downloadBtn.disabled = false;
            progressDiv.style.display = 'none';
        }
    }

    function performAggregation() {
        return new Promise(async (resolve, reject) => {
            try {
                // Get bounds and settings
                const xMin = parseFloat(xMinInput.value) || 0;
                const xMax = parseFloat(xMaxInput.value) || 360;
                const yMin = (parseFloat(yMinInput.value) || 0) * 1000;
                const yMax = (parseFloat(yMaxInput.value) || 40) * 1000;
                
                // Calculate plot area using SAMPLING resolution
                plotArea = calculatePlotArea(xMin, xMax, yMin, yMax, 
                                          samplingResolution.width, samplingResolution.height);
                
                // Initialize aggregated data structure at SAMPLING resolution
                aggregatedData = initializeAggregatedData(samplingResolution.width, samplingResolution.height);
                
                // Process data from database
                const db = await openDatabase();
                const totalCount = await getRecordCount(db);
                
                await processDatabaseRecords(db, {
                    xMin, xMax, yMin, yMax,
                    totalCount, plotArea
                });
                
                resolve();
            } catch (error) {
                reject(error);
            }
        });
    }
	
	    function updateAggregatedData(data, x, y, entry) {
        const cell = data[x][y];
        
        // Update basic statistics
        cell.sumSNR += entry.snr;
        cell.count++;
        
        // Update min/max
        if (entry.snr < cell.minSNR) cell.minSNR = entry.snr;
        if (entry.snr > cell.maxSNR) cell.maxSNR = entry.snr;
        
        // Update first/last
        if (cell.firstSNR === null) {
            cell.firstSNR = entry.snr;
        }
        cell.lastSNR = entry.snr;
    }
	
	function calculatePlotArea(xMin, xMax, yMin, yMax, width, height) {
		// Use fixed padding values that will be consistent across resolutions
		const padding = { 
			top: 20 * (height / 1080),    // Scale padding relative to 1080p
			right: 40 * (width / 1920),    // Scale padding relative to 1920p
			bottom: 40 * (height / 1080),
			left: 60 * (width / 1920)
		};
		
		return {
			plotX: padding.left,
			plotY: padding.top,
			plotWidth: width - padding.left - padding.right,
			plotHeight: height - padding.top - padding.bottom,
			xAxisY: height - padding.bottom,
			yAxisX: padding.left
		};
	}

    // =============================================
    // 3. RENDERING FUNCTIONS
    // =============================================

	function drawALL() {
		if (!isDataAggregated) {
			statusDiv.textContent = "Please aggregate data first!";
			return;
		}

		try {
			statusDiv.textContent = "Rendering plot...";
			
			// Get resolutions and settings
			plotResolution = getPlotResolution();
			MIN_SNR = parseFloat(snrMinInput.value) || 8;
			MAX_SNR = parseFloat(snrMaxInput.value) || 28;
			const xMin = parseFloat(xMinInput.value) || 0;
			const xMax = parseFloat(xMaxInput.value) || 360;
			const yMin = (parseFloat(yMinInput.value) || 0) * 1000;
			const yMax = (parseFloat(yMaxInput.value) || 40) * 1000;
			
			// Create high-res heatmap canvas
			const heatmapCanvas = document.createElement('canvas');
			heatmapCanvas.width = samplingResolution.width;
			heatmapCanvas.height = samplingResolution.height;
			const heatmapCtx = heatmapCanvas.getContext('2d');
			
			// Draw heatmap at full sampling resolution
			drawSNRPlot(heatmapCtx, aggregatedData, samplingResolution.width, samplingResolution.height);
			
			// Create display-resolution overlays canvas
			const overlaysCanvas = document.createElement('canvas');
			overlaysCanvas.width = plotResolution.width;
			overlaysCanvas.height = plotResolution.height;
			const overlaysCtx = overlaysCanvas.getContext('2d');
			
			// Calculate plot area for current display resolution
			plotArea = calculatePlotArea(xMin, xMax, yMin, yMax, 
									   plotResolution.width, plotResolution.height);
			
			// Draw crisp overlays at display resolution
			drawOverlays(overlaysCtx, plotResolution.width, plotResolution.height);
			
			// Set final canvas size
			setCanvasSize(plotResolution.width, plotResolution.height);
			
			// Composite both layers
			ctx.fillStyle = '#121212';
			ctx.fillRect(0, 0, canvas.width, canvas.height);
			
			// Quality scaling optimization
			const scalingRatio = plotResolution.width / samplingResolution.width;
			
			if (scalingRatio < QUALITY_SCALING_THRESHOLD) {
				// For large downscaling, use stepped approach
				const intermediateCanvas = document.createElement('canvas');
				
				// First step: scale to intermediate size (50% larger than target)
				const intermediateWidth = plotResolution.width * INTERMEDIATE_SCALE_FACTOR;
				const intermediateHeight = plotResolution.height * INTERMEDIATE_SCALE_FACTOR;
				
				intermediateCanvas.width = intermediateWidth;
				intermediateCanvas.height = intermediateHeight;
				const intermediateCtx = intermediateCanvas.getContext('2d');
				
				// First scaling pass
				intermediateCtx.imageSmoothingEnabled = true;
//				if ('imageSmoothingQuality' in intermediateCtx) {
//					intermediateCtx.imageSmoothingQuality = 'high'; // Chrome only - a bit sharpness
//				}
				intermediateCtx.drawImage(
					heatmapCanvas,
					0, 0, samplingResolution.width, samplingResolution.height,
					0, 0, intermediateWidth, intermediateHeight
				);
				
				// Final scaling to target size
				ctx.imageSmoothingEnabled = true;
//				if ('imageSmoothingQuality' in ctx) {
//					ctx.imageSmoothingQuality = 'high'; // Chrome only - a bit sharpness
//				}
				ctx.drawImage(
					intermediateCanvas,
					0, 0, intermediateWidth, intermediateHeight,
					0, 0, plotResolution.width, plotResolution.height
				);
			} else {
				// Direct scaling for moderate size reductions
				ctx.imageSmoothingEnabled = true;
				ctx.drawImage(
					heatmapCanvas,
					0, 0, samplingResolution.width, samplingResolution.height,
					0, 0, plotResolution.width, plotResolution.height
				);
			}
			
			// Draw overlays (no scaling needed)
			ctx.drawImage(overlaysCanvas, 0, 0);
			
		} catch (error) {
			console.error('Plot rendering failed:', error);
			statusDiv.textContent = `Error: ${error.message}`;
		}
	}
	
		function scaleCanvasForDisplay() {
		// Create a temporary canvas at the display resolution
		const displayCanvas = document.createElement('canvas');
		displayCanvas.width = plotResolution.width;
		displayCanvas.height = plotResolution.height;
		const displayCtx = displayCanvas.getContext('2d');
		
		// Scale down the high-res canvas
		displayCtx.scale(
			plotResolution.width / samplingResolution.width,
			plotResolution.height / samplingResolution.height
		);
		displayCtx.drawImage(canvas, 0, 0);
		
		// Clear the original canvas and draw the scaled version
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		canvas.width = plotResolution.width;
		canvas.height = plotResolution.height;
		ctx.drawImage(displayCanvas, 0, 0);
	}


	function scaleAggregatedDataToPlotResolution() {
		renderedData = initializeAggregatedData(plotResolution.width, plotResolution.height);
		
		// Calculate scaling factors
		const xScale = samplingResolution.width / plotResolution.width;
		const yScale = samplingResolution.height / plotResolution.height;
		
		// For each pixel in the destination (plot resolution)
		for (let destX = 0; destX < plotResolution.width; destX++) {
			for (let destY = 0; destY < plotResolution.height; destY++) {
				// Calculate the corresponding area in the source (sampling resolution)
				const srcXStart = Math.floor(destX * xScale);
				const srcXEnd = Math.min(samplingResolution.width - 1, Math.ceil((destX + 1) * xScale));
				const srcYStart = Math.floor(destY * yScale);
				const srcYEnd = Math.min(samplingResolution.height - 1, Math.ceil((destY + 1) * yScale));
				
				// Initialize accumulators
				let sumSNR = 0;
				let count = 0;
				let minSNR = Infinity;
				let maxSNR = -Infinity;
				let firstSNR = null;
				let lastSNR = null;
				
				// Average all source cells that contribute to this destination pixel
				for (let srcX = srcXStart; srcX <= srcXEnd; srcX++) {
					for (let srcY = srcYStart; srcY <= srcYEnd; srcY++) {
						const cell = aggregatedData[srcX][srcY];
						if (cell.count >= 2) {  // Averaging of 1 point is omited as it is useless
							sumSNR += cell.sumSNR;
							count += cell.count;
							minSNR = Math.min(minSNR, cell.minSNR);
							maxSNR = Math.max(maxSNR, cell.maxSNR);
							firstSNR = firstSNR === null ? cell.firstSNR : firstSNR;
							lastSNR = cell.lastSNR;
						}
					}
				}
				
				// Store the averaged values
				if (count > 0) {
					renderedData[destX][destY] = {
						sumSNR: sumSNR,
						count: count,
						minSNR: minSNR,
						maxSNR: maxSNR,
						firstSNR: firstSNR,
						lastSNR: lastSNR
					};
				}
			}
		}
		
//		maxCount = calculateMaxCount(renderedData);
	}

	function drawSNRPlot(ctxToUse, dataToUse, width, height) {
		const snrType = snrTypeSelect.value;
		const imageData = ctxToUse.createImageData(width, height);
		const data = imageData.data;
		
		// render using provided data
		for (let x = 0; x < width; x++) {
			for (let y = 0; y < height; y++) {
				const cell = dataToUse[x][y];
				const idx = (y * width + x) * 4;
				
				if (cell.count >= MIN_CELL_COUNT) {
					const value = getCellValue(cell, snrType);
					let [r, g, b] = getColorForSNR(value);
					
					if (densityEnabled) {
						let brightness = 0;
						if (cell.count > DENSITY_MAX) {
							brightness = 1;
						} else {
							const densityFactor = Math.pow(cell.count / DENSITY_MAX, DENSITY_STRENGTH);
							brightness = DENSITY_MIN_BRIGHTNESS + (1 - DENSITY_MIN_BRIGHTNESS) * densityFactor;
						}
						r = Math.min(255, r * brightness);
						g = Math.min(255, g * brightness);
						b = Math.min(255, b * brightness);
					}
					
					data[idx] = r;
					data[idx + 1] = g;
					data[idx + 2] = b;
					data[idx + 3] = 255;
				} else {
					data[idx] = data[idx + 1] = data[idx + 2] = data[idx + 3] = 0;
				}
			}
		}
		
		ctxToUse.putImageData(imageData, 0, 0);
	}

	// =============================================
    // 3. DATABASE FUNCTIONS
    // =============================================

function openDatabase() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open('RadiosondeDB', 2);
        
        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains('logEntries')) {
                const store = db.createObjectStore('logEntries', { keyPath: 'id', autoIncrement: true });
                store.createIndex('azimuth', 'azimuth', { unique: false });
                store.createIndex('alt', 'alt', { unique: false });
                store.createIndex('snr', 'snr', { unique: false });
                store.createIndex('distance', 'distance', { unique: false });
            }
        };
        
        request.onsuccess = () => resolve(request.result);
        request.onerror = (event) => {
            console.error("Database error:", event.target.error);
            reject(new Error("Couldn't open database"));
        };
    });
}

    function getRecordCount(db) {
        return new Promise((resolve) => {
            const tx = db.transaction(['logEntries'], 'readonly');
            const store = tx.objectStore('logEntries');
            const request = store.count();
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => resolve(0);
        });
    }

    function getRecordsBatch(db, lastKey, batchSize) {
        return new Promise((resolve) => {
            const tx = db.transaction(['logEntries'], 'readonly');
            const store = tx.objectStore('logEntries');
            const request = lastKey 
                ? store.openCursor(IDBKeyRange.lowerBound(lastKey, true))
                : store.openCursor();
            
            const batch = [];
            let counter = 0;
            
            request.onsuccess = (event) => {
                const cursor = event.target.result;
                if (!cursor || counter >= batchSize) {
                    return resolve(batch);
                }
                
                batch.push(cursor.value);
                counter++;
                cursor.continue();
            };
            
            request.onerror = () => resolve(batch);
        });
    }
	
	async function processDatabaseRecords(db, params) {
		const { xMin, xMax, yMin, yMax, totalCount, plotArea } = params;
		const { plotX, plotY, plotWidth, plotHeight, xAxisY } = plotArea;
		
		let lastKey = null;
		let processed = 0;
		let renderedCount = 0;
		lastUpdate = 0;
		
		// Process in batches
		while (processed < totalCount && renderedCount < MAX_POINTS) {
			const batch = await getRecordsBatch(db, lastKey, BATCH_SIZE);
			if (batch.length === 0) break;
			
			for (let i = 0; i < batch.length; i++) {
				const entry = batch[i];
				if (isValidEntry(entry, xMin, xMax, yMin, yMax)) {
					// Calculate position in SAMPLING resolution grid
					const x = Math.round(plotX + ((entry.azimuth - xMin) / (xMax - xMin)) * plotWidth);
					const y = Math.round(xAxisY - ((entry.alt - yMin) / (yMax - yMin)) * plotHeight);
					
					// Ensure within SAMPLING resolution bounds
					if (x >= 0 && x < samplingResolution.width && 
						y >= 0 && y < samplingResolution.height) {
						updateAggregatedData(aggregatedData, x, y, entry);
						renderedCount++;
					}
					
					if (renderedCount >= MAX_POINTS) {
						console.log("Reached the limit of MAX_POINTS:", MAX_POINTS,  " GD RX! , change the limit or spearate the logs by years.");
						break;
					}
				}
				
				lastKey = entry.id;
				processed++;
			}
			
			updateProgress(processed, totalCount);
			await new Promise(resolve => setTimeout(resolve, 0));
		}
		
		maxCount = calculateMaxCount(aggregatedData); // used for normalisation of Brightness by Density, not used anymore
		console.log("maxCount:", maxCount, "Data Points:", renderedCount);
		return renderedCount;
	}
	
	function calculateMaxCount(data) {
        let max = 1;
        for (let x = 0; x < data.length; x++) {
            for (let y = 0; y < data[x].length; y++) {
                if (data[x][y].count > max) {
                    max = data[x][y].count;
                }
            }
        }
        return max;
    }
	
function isValidEntry(entry, xMin, xMax, yMin, yMax) {
    if (!entry || typeof entry !== 'object') return false;
    
    // Check required fields exist and are valid numbers
    const requiredFields = ['azimuth', 'alt', 'snr', 'distance'];
    for (const field of requiredFields) {
        if (typeof entry[field] !== 'number' || isNaN(entry[field])) {
            return false;
        }
    }
    
    // Get distance filter values
    const zMin = parseFloat(zMinInput.value) || 0;
    const zMax = parseFloat(zMaxInput.value) || 900;
    
    return entry.azimuth >= xMin && 
           entry.azimuth <= xMax && 
           entry.alt >= yMin && 
           entry.alt <= yMax &&
           entry.distance >= zMin &&
           entry.distance <= zMax;
}
	
    function updateProgress(processed, totalCount) {
        const now = Date.now();
        if (now - lastUpdate > 100) {
            const progress = Math.min(100, (processed / totalCount) * 100);
            progressBar.style.width = `${progress}%`;
            statusDiv.textContent = `Processed ${Math.min(processed, totalCount).toLocaleString()} of ${totalCount.toLocaleString()} records (aggregating data)...`;
            lastUpdate = now;
        }
    }

    // =============================================
    // 4. DRAWING FUNCTIONS
    // =============================================
    function setCanvasSize(width, height) {
        canvas.width = width;
        canvas.height = height;
    }
	
	function drawOverlays(ctxToUse, width, height) {
		const xMin = parseFloat(xMinInput.value) || 0;
		const xMax = parseFloat(xMaxInput.value) || 360;
		const yMin = (parseFloat(yMinInput.value) || 0) * 1000;
		const yMax = (parseFloat(yMaxInput.value) || 40) * 1000;
		
		// Draw axes and grid
		drawAxesAndGrid(ctxToUse, xMin, xMax, yMin, yMax, width, height);
		
		// Draw color bar legend
		drawColorBarLegend(ctxToUse, plotArea);
		
		// Draw density bar legend
		drawDensityLegend(ctxToUse, plotArea);
		
		// Draw horizon curves if enabled
		if (losEnabled.checked || radioHorizonEnabled.checked) {
			const observerHeight = parseFloat(observerHeightInput.value) || 0;
			const refractionFactor = parseFloat(refractionFactorInput.value) || 1.33;
			
			if (radioHorizonEnabled.checked) {
				drawHorizonCurve(ctxToUse, xMin, xMax, yMin, yMax, plotArea,
					observerHeight, 6371, radioHorizonColorInput.value,
					'Radio Horizon', refractionFactor);
			}
			
			if (losEnabled.checked) {
				drawHorizonCurve(ctxToUse, xMin, xMax, yMin, yMax, plotArea,
					observerHeight, 6371, losColorInput.value, 'LOS');
			}
		}
	}

    // =============================================
    // 5. HELPER FUNCTIONS
    // =============================================
	// Helper function to get the appropriate value from a cell
	function getCellValue(cell, snrType) {
		switch(snrType) {
			case 'first': return cell.firstSNR;
			case 'last': return cell.lastSNR;
			case 'min': return cell.minSNR;
			case 'max': return cell.maxSNR;
			case 'count': return cell.count;
			case 'sum': return cell.sumSNR;
			case 'avg':
			default: return cell.sumSNR / cell.count;
		}
	}
	
    function getSamplingResolution() {
        const [width, height] = SresolutionSelect.value.split('x').map(Number);
        return { width, height };
    }

    function getPlotResolution() {
        const [width, height] = PresolutionSelect.value.split('x').map(Number);
        return { width, height };
    }

    function getColorForSNR(snr) {
        if (isNaN(snr)) return [0, 0, 0, 0];
        
        // Normalize SNR value between MIN_SNR and MAX_SNR to 0-1 range
        const normalized = Math.min(1, Math.max(0, (snr - MIN_SNR) / (MAX_SNR - MIN_SNR)));
        
        // Get selected color scheme
        const scheme = document.getElementById('colorScheme').value;
        const stops = COLOR_SCHEMES[scheme];
        
        // Find the two stops the normalized value falls between
        let lower = stops[0];
        let upper = stops[stops.length - 1];
        
        for (let i = 0; i < stops.length; i++) {
            if (stops[i][0] >= normalized) {
                upper = stops[i];
                lower = i > 0 ? stops[i-1] : upper;
                break;
            }
        }
        
        // If exactly on a stop point, return that color
        if (lower[0] === upper[0]) {
            return [lower[1], lower[2], lower[3]];
        }
        
        // Linearly interpolate between the two colors
        const t = (normalized - lower[0]) / (upper[0] - lower[0]);
        
        return [
            Math.round(lower[1] + t * (upper[1] - lower[1])),  // R
            Math.round(lower[2] + t * (upper[2] - lower[2])),  // G
            Math.round(lower[3] + t * (upper[3] - lower[3]))   // B
        ];
    }

    function calculateLineOfSight(altitude, observerHeight, earthRadius, refractionFactor = 1) {
        const effectiveRadius = earthRadius * 1000 * refractionFactor;
        const d1 = Math.sqrt(2 * effectiveRadius * observerHeight + observerHeight * observerHeight);
        const d2 = Math.sqrt(2 * effectiveRadius * altitude + altitude * altitude);
        return d1 + d2;
    }

    function drawHorizonCurve(ctx, xMin, xMax, yMin, yMax, plotArea, 
                           observerHeight, earthRadius, color, label, refractionFactor = 1) {
        const { plotX, plotY, plotWidth, plotHeight, xAxisY } = plotArea;
        
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        
        const steps = 100;
        const stepSize = (xMax - xMin) / steps;
        
        for (let i = 0; i <= steps; i++) {
            const distance = xMin + i * stepSize;
            const distanceMeters = distance * 1000;
            
            const R = earthRadius * 1000 * refractionFactor;
            const d1 = Math.sqrt(2 * R * observerHeight + observerHeight * observerHeight);
            let altitude = 0;
            
            if (distanceMeters > d1) {
                const remainingDistance = distanceMeters - d1;
                altitude = (Math.pow(remainingDistance, 2) - 2 * R * observerHeight) / (2 * R);
                altitude = Math.max(0, altitude);
            }
            
            const x = plotX + ((distance - xMin) / (xMax - xMin)) * plotWidth;
            const y = xAxisY - ((altitude - yMin) / (yMax - yMin)) * plotHeight;
            
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        
        ctx.stroke();
        
        // Add labels
        const defSondeHeight = 35000;
        const defSondeHeightKm = defSondeHeight * METERS_TO_KM;
        const defDistance = calculateLineOfSight(defSondeHeight, observerHeight, earthRadius, refractionFactor) / 1000;
        const maxDistance = calculateLineOfSight(yMax, observerHeight, earthRadius, refractionFactor) / 1000;
        const labelX = plotX + plotWidth * 0.98;
        const labelY = xAxisY - (label === 'LOS' ? 120 : 80);
        
        ctx.fillStyle = color;
        ctx.font = '16px Arial';
        ctx.textAlign = 'right';
        ctx.fillText(`Typical ${label} ${observerHeight}m to ${defSondeHeightKm.toFixed(1)}km: ~${defDistance.toFixed(1)} km`, labelX, labelY);
        ctx.fillText(`${label} from ${observerHeight}m to ${(yMax * METERS_TO_KM).toFixed(1)}km: ~${maxDistance.toFixed(1)} km`, labelX, labelY-20);
    }

    function drawColorBarLegend(ctx, plotArea) {
        const { plotX, plotY, plotWidth, plotHeight, xAxisY } = plotArea;
        
        // Color bar dimensions
        const barHeight = 20;
        const barWidth = 360;
        const barX = plotX + 22 + (plotWidth - 60 - barWidth) * 0.5;
        const barY = 44;
        
        // Draw the color gradient
        for (let i = 0; i < barWidth; i++) {
            const normalized = i / barWidth;
            const snr = MIN_SNR + normalized * (MAX_SNR - MIN_SNR);
            const [r, g, b] = getColorForSNR(snr);
            ctx.fillStyle = `rgb(${r},${g},${b})`;
            ctx.fillRect(barX + i, barY, 1, barHeight);
        }
        
        // Draw border
        ctx.strokeStyle = '#aaa';
        ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, barWidth, barHeight);
        
        // Add title
        ctx.fillStyle = '#aaa';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('SNR (dB)', barX + barWidth / 2, barY - 8);
        
        // Add tick marks and labels
        const tickCount = 7;
        ctx.font = '12px Arial';
        
        for (let i = 0; i < tickCount; i++) {
            const snr = MIN_SNR + (i / (tickCount - 1)) * (MAX_SNR - MIN_SNR);
            const x = barX + (i / (tickCount - 1)) * barWidth;
            
            ctx.beginPath();
            ctx.moveTo(x, barY + barHeight);
            ctx.lineTo(x, barY + barHeight + 5);
            ctx.stroke();
            
            ctx.fillText(snr.toFixed(0), x, barY + barHeight + 20);
        }
    }

    function drawDensityLegend(ctx, plotArea) {
        const { plotX, plotY, plotWidth, plotHeight, xAxisY } = plotArea;
        
        const barHeight = 20;
        const barWidth = 100;
        const barX = plotX + plotWidth - barWidth - 40;
        const barY = 44;
        
        // Only draw if density is enabled
        if (densityEnabled) {
		    // Labels
			ctx.fillStyle = '#aaa';
			ctx.font = '12px Arial';
			ctx.textAlign = 'center';
			ctx.fillText('Density', barX + barWidth/2, barY - 8);
			ctx.textAlign = 'right';
            ctx.fillText('0', barX + 6, barY - 8);
            ctx.textAlign = 'left';
            ctx.fillText(DENSITY_MAX, barX + barWidth - 12, barY - 8);
			// Density bar
            const gradient = ctx.createLinearGradient(barX, barY, barX + barWidth, barY);
            gradient.addColorStop(0, `rgba(255,255,255,${DENSITY_MIN_BRIGHTNESS})`);
            gradient.addColorStop(1, 'rgba(255,255,255,1)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(barX, barY, barWidth, barHeight);
            
            ctx.strokeStyle = '#aaa';
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
        }
    }

	function drawAxesAndGrid(ctx, xMin, xMax, yMin, yMax, width, height) {
		// Convert yMin and yMax from meters to kilometers for display
		const yMinKm = yMin * METERS_TO_KM;
		const yMaxKm = yMax * METERS_TO_KM;
		
		// Set drawing style
		ctx.strokeStyle = '#aaa';
		ctx.fillStyle = '#aaa';
		ctx.lineWidth = 1;
		ctx.font = '12px Arial';
		ctx.textAlign = 'center';
		ctx.textBaseline = 'middle';
		
		// Use the same padding calculation as calculatePlotArea
		const padding = { 
			top: 20 * (height / 1080),
			right: 40 * (width / 1920),
			bottom: 40 * (height / 1080),
			left: 60 * (width / 1920)
		};
        
        // Calculate axis positions
        const xAxisY = height - padding.bottom;
        const yAxisX = padding.left;
        
        // Draw X axis
        ctx.beginPath();
        ctx.moveTo(yAxisX, xAxisY);
        ctx.lineTo(width - padding.right, xAxisY);
        ctx.stroke();
        
        // Draw Y axis
        ctx.beginPath();
        ctx.moveTo(yAxisX, padding.top);
        ctx.lineTo(yAxisX, xAxisY);
        ctx.stroke();
        
        // Calculate tick intervals
        const xRange = xMax - xMin;
        const yRangeKm = yMaxKm - yMinKm;
        
        // Smart tick calculation
        const xTickInterval = calculateTickInterval(xRange, width - padding.left - padding.right);
        const yTickIntervalKm = calculateTickInterval(yRangeKm, height - padding.top - padding.bottom);
        
        // Draw X axis ticks and labels
        let firstXTick = Math.ceil(xMin / xTickInterval) * xTickInterval;
        for (let x = firstXTick; x <= xMax; x += xTickInterval) {
            const canvasX = padding.left + ((x - xMin) / xRange) * (width - padding.left - padding.right);
            
            // Tick mark
            ctx.beginPath();
            ctx.moveTo(canvasX, xAxisY);
            ctx.lineTo(canvasX, xAxisY + 5);
            ctx.stroke();
            
            // Label
            const xLabel = x % 1 === 0 ? x.toString() : x.toFixed(1);
            ctx.fillText(xLabel + '\u00B0', canvasX, xAxisY + 20);
            
            // Grid line
            ctx.strokeStyle = '#333';
            ctx.setLineDash([2, 2]);
            ctx.beginPath();
            ctx.moveTo(canvasX, padding.top);
            ctx.lineTo(canvasX, xAxisY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.strokeStyle = '#aaa';
        }
        
        // Draw Y axis ticks and labels - using km values
        let firstYTickKm = Math.ceil(yMinKm / yTickIntervalKm) * yTickIntervalKm;
        for (let yKm = firstYTickKm; yKm <= yMaxKm; yKm += yTickIntervalKm) {
            // Convert back to meters for positioning
            const yMeters = yKm / METERS_TO_KM;
            const canvasY = height - padding.bottom - ((yMeters - yMin) / (yMax - yMin)) * (height - padding.top - padding.bottom);
            
            // Tick mark
            ctx.beginPath();
            ctx.moveTo(yAxisX, canvasY);
            ctx.lineTo(yAxisX - 5, canvasY);
            ctx.stroke();
            
            // Label - showing km values
            const yLabel = yKm % 1 === 0 ? yKm.toString() : yKm.toFixed(1);
            ctx.textAlign = 'right';
            ctx.fillText(yLabel + 'km', yAxisX - 8, canvasY);
            
            // Grid line
            ctx.strokeStyle = '#333';
            ctx.setLineDash([2, 2]);
            ctx.beginPath();
            ctx.moveTo(yAxisX, canvasY);
            ctx.lineTo(width - padding.right, canvasY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.strokeStyle = '#aaa';
        }
        
        // Draw axis labels
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
		// Draw X axis label
		const firstXPos = padding.left + ((firstXTick - xMin) / xRange) * (width - padding.left - padding.right);
		const secondXPos = padding.left + (((firstXTick + xTickInterval) - xMin) / xRange) * (width - padding.left - padding.right);
		const xLabelPos = firstXPos + (secondXPos - firstXPos) / 2;
		ctx.fillText('AZ.', xLabelPos, xAxisY + 20);
        
		// Draw Y axis label (between first and second ticks, horizontal)
		const firstY = height - padding.bottom - ((firstYTickKm/METERS_TO_KM - yMin)/(yMax - yMin)) * (height - padding.top - padding.bottom);
		const secondY = height - padding.bottom - (((firstYTickKm + yTickIntervalKm)/METERS_TO_KM - yMin)/(yMax - yMin) * (height - padding.top - padding.bottom));
		ctx.textAlign = 'right';
		ctx.fillText('ALT.', padding.left - 5, (firstY + secondY)/2);
        
        // Draw title
        ctx.font = 'bold 18px Arial';
		ctx.textAlign = 'center';
        ctx.fillText('Radiosonde SNR vs Altitude and Azimuth', width / 2, 15);
        
        // Return the plotting area dimensions
        return {
            plotX: padding.left,
            plotY: padding.top,
            plotWidth: width - padding.left - padding.right,
            plotHeight: height - padding.top - padding.bottom,
            xAxisY: xAxisY,
            yAxisX: yAxisX
        };
    }

    function calculateTickInterval(range, pixels) {
        const targetTicks = pixels / 100;
        const roughInterval = range / targetTicks;
        
        const magnitude = Math.pow(10, Math.floor(Math.log10(roughInterval)));
        const normalized = roughInterval / magnitude;
        
        let niceInterval;
        if (normalized < 1.5) {
            niceInterval = magnitude;
        } else if (normalized < 3) {
            niceInterval = 2 * magnitude;
        } else if (normalized < 7) {
            niceInterval = 5 * magnitude;
        } else {
            niceInterval = 10 * magnitude;
        }
        
        return niceInterval;
    }
	function disableControls() {
		const controls = [
			SresolutionSelect,
			aggregateBtn,
			xMinInput,
			xMaxInput,
			yMinInput,
			yMaxInput,
			zMinInput,
			zMaxInput,
			viewBtn,
			downloadBtn
		];
		
		controls.forEach(control => {
			control.disabled = true;
		});
	}
	
	function renderAndPreview() {
		const renderStart = performance.now();
		if (!isDataAggregated) return;
		drawALL(); // Render the full quality plot first
		// Set preview canvas size
		previewCanvas.width = 800;
		previewCanvas.height = Math.round(800 * (canvas.height / canvas.width));

		const scalingRatio = previewCanvas.width / canvas.width;
		
		if (scalingRatio < QUALITY_SCALING_THRESHOLD) {
			// Two-step scaling for large reductions (better quality)
			const intermediateWidth = previewCanvas.width * INTERMEDIATE_SCALE_FACTOR;
			const intermediateHeight = previewCanvas.height * INTERMEDIATE_SCALE_FACTOR;
			const intermediateCanvas = document.createElement('canvas');
			intermediateCanvas.width = intermediateWidth;
			intermediateCanvas.height = intermediateHeight;
			const intermediateCtx = intermediateCanvas.getContext('2d');
			
			// First step: Scale to intermediate size
			intermediateCtx.imageSmoothingEnabled = true;
//			if ('imageSmoothingQuality' in intermediateCtx) {
//				intermediateCtx.imageSmoothingQuality = 'high';  // Chrome only - a bit sharpness
//			}
			intermediateCtx.drawImage(
				canvas,
				0, 0, canvas.width, canvas.height,
				0, 0, intermediateWidth, intermediateHeight
			);
			
			// Second step: Scale to final preview size
			previewCtx.imageSmoothingEnabled = true;
//			if ('imageSmoothingQuality' in previewCtx) {
//				previewCtx.imageSmoothingQuality = 'high';  // Chrome only - a bit sharpness
//			}
			previewCtx.drawImage(
				intermediateCanvas,
				0, 0, intermediateWidth, intermediateHeight,
				0, 0, previewCanvas.width, previewCanvas.height
			);
		} else {
			// Direct scaling for moderate reductions
			previewCtx.imageSmoothingEnabled = true;
			previewCtx.drawImage(
				canvas,
				0, 0, canvas.width, canvas.height,
				0, 0, previewCanvas.width, previewCanvas.height
			);
		}
		
		previewContainer.style.display = 'block';
		const renderTime = performance.now() - renderStart;
		statusDiv.textContent = `Render and Draw complete in ${renderTime.toFixed(0)}ms !`;
	}
	
	function updateDensityControlsState() {
		const isEnabled = densityEnabled;
		densityMinBrightnessInput.disabled = !isEnabled;
		densityStrengthInput.disabled = !isEnabled;
		densityMaxInput.disabled = !isEnabled;
		densityControlsContainer.style.opacity = isEnabled ? '1' : '0.6';
	}


    // =============================================
    // 6. EVENT HANDLERS
    // =============================================

    aggregateBtn.addEventListener('click', async function() {
        await aggregateData();
		renderAndPreview();
    });
	
	renderBtn.addEventListener('click', function() {
		renderAndPreview();
    });
	
	// Render and Preview auto after changes
	PresolutionSelect.addEventListener('change', function() {
		renderAndPreview();
	});
	
	// SNR type
	snrTypeSelect.addEventListener('change', function() {
		snrType = this.value;
		// Auto-adjust SNR range when switching to sum/count modes
		switch(snrType) {
			case 'count':
					snrMin = 1;    // COLD color for cells with at least 1 count
					snrMax = 50;  // HOT color for 50 or more counts
					snrMinInput.value = snrMin;
					snrMaxInput.value = snrMax;
				break;
				
			case 'sum':
					snrMin = 20;    // COLD color for sum SNR <= 20
					snrMax = 200;  // HOT color at sum SNR >= 200
					snrMinInput.value = snrMin;
					snrMaxInput.value = snrMax;
				break;
		}
		renderAndPreview();
	});
	snrMinInput.addEventListener('change', function() {
		snrMin = this.value;
		renderAndPreview();
	});
	snrMaxInput.addEventListener('change', function() {
		snrMax = this.value;
		renderAndPreview();
	});
	// Add event listeners for the density control inputs
	[densityMinBrightnessInput, densityStrengthInput, densityMaxInput].forEach(input => {
		input.addEventListener('change', function() {
		    DENSITY_MIN_BRIGHTNESS = parseFloat(densityMinBrightnessInput.value) / 100; // Convert % to 0-1.0
			DENSITY_STRENGTH = parseFloat(densityStrengthInput.value);
			DENSITY_MAX = parseInt(densityMaxInput.value);
			renderAndPreview();
		});
    });
	document.getElementById('densityEnabled').addEventListener('change', function() {
		densityEnabled = this.checked;
		updateDensityControlsState();
		renderAndPreview();
	});

	colorSchemeSelect.addEventListener('change', function() {
		renderAndPreview();
	});

	viewBtn.onclick = function() {
		// Create a high-quality version for modal
		const tempCanvas = document.createElement('canvas');
		tempCanvas.width = plotResolution.width;
		tempCanvas.height = plotResolution.height;
		const tempCtx = tempCanvas.getContext('2d');
		
		// Fill background
		tempCtx.fillStyle = '#121212';
		tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
		
		// Draw the heatmap with smoothing
		tempCtx.imageSmoothingEnabled = true;
		tempCtx.drawImage(canvas, 0, 0);
		
		// Show modal
		modal.style.display = "block";
		modalImg.src = tempCanvas.toDataURL('image/png', 1.0); // Maximum quality
		document.body.style.overflow = "hidden";
	};

    downloadBtn.addEventListener('click', function() {
        if (!isDataAggregated) {
            statusDiv.textContent = "No data to download - please aggregate and render first!";
            return;
        }
        
        // Create a temporary canvas with background
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        const tempCtx = tempCanvas.getContext('2d');
        
        // Fill with background color
        tempCtx.fillStyle = '#121212';
        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
        
        // Draw the heatmap
        tempCtx.drawImage(canvas, 0, 0);
        
        // Create download link
        const link = document.createElement('a');
        link.download = 'snr-az-alt-plot-' + new Date().toISOString().slice(0, 10) + '.png';
        link.href = tempCanvas.toDataURL('image/png');
        link.click();
    });

    // Close modal when clicking [X]
    span.onclick = function() {
        modal.style.display = "none";
        document.body.style.overflow = "auto";
    };

    // Close modal when clicking outside image
    modal.onclick = function(event) {
        if (event.target === modal) {
            modal.style.display = "none";
            document.body.style.overflow = "auto";
        }
    };

    // Close modal with ESC key
    document.addEventListener('keydown', function(event) {
        if (event.key === "Escape" && modal.style.display === "block") {
            modal.style.display = "none";
            document.body.style.overflow = "auto";
        }
    });

    // Initialize
    function initialize() {
        aggregateBtn.disabled = false; 
        SresolutionSelect.disabled = false; 
        renderBtn.disabled = true;
        viewBtn.disabled = true;
        downloadBtn.disabled = true;
        statusDiv.textContent = "Select settings and click Aggregate Data";
        updateDensityControlsState();
		densityMinBrightnessInput.value = DENSITY_MIN_BRIGHTNESS * 100; // Convert to percentage
		densityStrengthInput.value = DENSITY_STRENGTH;
		densityMaxInput.value = DENSITY_MAX;
        // Set initial resolutions
        samplingResolution = getSamplingResolution();
        plotResolution = getPlotResolution();
    }

    initialize();
</script>
</body>
</html>
